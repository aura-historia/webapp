// This file is auto-generated by @hey-api/openapi-ts

import { queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { addWatchlistProduct, complexSearchProducts, createShop, createUserSearchFilter, deleteUserSearchFilter, deleteWatchlistProduct, getProduct, getShop, getSimilarProducts, getUserAccount, getUserSearchFilter, getUserSearchFilters, getWatchlistProducts, type Options, patchWatchlistProduct, putProducts, searchShops, updateShop, updateUserAccount, updateUserSearchFilter } from '../sdk.gen';
import type { AddWatchlistProductData, AddWatchlistProductError, AddWatchlistProductResponse, ComplexSearchProductsData, ComplexSearchProductsError, ComplexSearchProductsResponse, CreateShopData, CreateShopError, CreateShopResponse, CreateUserSearchFilterData, CreateUserSearchFilterError, CreateUserSearchFilterResponse, DeleteUserSearchFilterData, DeleteUserSearchFilterError, DeleteUserSearchFilterResponse, DeleteWatchlistProductData, DeleteWatchlistProductError, DeleteWatchlistProductResponse, GetProductData2, GetProductError, GetProductResponse, GetShopData2, GetShopError, GetShopResponse, GetSimilarProductsData, GetSimilarProductsError, GetSimilarProductsResponse, GetUserAccountData2, GetUserAccountError, GetUserAccountResponse, GetUserSearchFilterData, GetUserSearchFilterError, GetUserSearchFilterResponse, GetUserSearchFiltersData, GetUserSearchFiltersError, GetUserSearchFiltersResponse, GetWatchlistProductsData, GetWatchlistProductsError, GetWatchlistProductsResponse, PatchWatchlistProductData, PatchWatchlistProductError, PatchWatchlistProductResponse, PutProductsData, PutProductsError, PutProductsResponse2, SearchShopsData, SearchShopsError, SearchShopsResponse, UpdateShopData, UpdateShopError, UpdateShopResponse, UpdateUserAccountData, UpdateUserAccountError, UpdateUserAccountResponse, UpdateUserSearchFilterData, UpdateUserSearchFilterError, UpdateUserSearchFilterResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const getProductQueryKey = (options: Options<GetProductData2>) => createQueryKey('getProduct', options);

/**
 * Get a single product
 *
 * Retrieves a single product by its shop ID and shop's product ID.
 * Returns localized content based on Accept-Language header and currency preferences.
 * Optionally includes product history when requested.
 *
 * **Personalization**: When authenticated (via optional Authorization header), the response includes
 * user-specific state such as whether the product is on the user's watchlist and notification preferences.
 * Anonymous requests receive product data without user state.
 *
 */
export const getProductOptions = (options: Options<GetProductData2>) => queryOptions<GetProductResponse, GetProductError, GetProductResponse, ReturnType<typeof getProductQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getProduct({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getProductQueryKey(options)
});

export const getSimilarProductsQueryKey = (options: Options<GetSimilarProductsData>) => createQueryKey('getSimilarProducts', options);

/**
 * Get similar products
 *
 * Retrieves products similar to the specified product using semantic search based on text embeddings.
 * Returns localized content based on Accept-Language header and currency preferences.
 *
 * **Personalization**: When authenticated (via optional Authorization header), the response includes
 * user-specific state for each similar product (watchlist status, notifications).
 * Anonymous requests receive product data without user state.
 *
 * **Asynchronous Processing**: If the product's text embedding has not yet been computed (typically for
 * products created less than 24 hours ago), the endpoint returns 202 Accepted with a Location header
 * to poll. The embedding generation runs nightly via batch processing.
 *
 */
export const getSimilarProductsOptions = (options: Options<GetSimilarProductsData>) => queryOptions<GetSimilarProductsResponse, GetSimilarProductsError, GetSimilarProductsResponse, ReturnType<typeof getSimilarProductsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getSimilarProducts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getSimilarProductsQueryKey(options)
});

/**
 * Bulk create or update products
 *
 * Creates or updates multiple products in a single batch request.
 * This endpoint accepts a collection of product data and processes them asynchronously.
 *
 * **Shop Enrichment**: The shop information (shopId and shopName) is automatically
 * enriched based on the product's URL. The domain is extracted from the product URL
 * and must match a shop that is already registered in the system. If the shop is not
 * found, the product will fail with a SHOP_NOT_FOUND error. If the URL does not contain
 * a valid extractable domain, the product will fail with a NO_DOMAIN error.
 *
 * **Response Structure**:
 * - `skipped`: Number of products that had no changes and were skipped
 * - `unprocessed`: URLs of products that could not be processed due to temporary issues (can be retried)
 * - `failed`: Map of product URLs to error codes for products that permanently failed processing
 *
 * Returns information about any products that could not be processed or failed during enrichment.
 *
 */
export const putProductsMutation = (options?: Partial<Options<PutProductsData>>): UseMutationOptions<PutProductsResponse2, PutProductsError, Options<PutProductsData>> => {
    const mutationOptions: UseMutationOptions<PutProductsResponse2, PutProductsError, Options<PutProductsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await putProducts({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Complex product search
 *
 * Performs an advanced search for products using a comprehensive search filter.
 * This endpoint accepts a ProductSearchData object in the request body,
 * allowing for complex filtering by multiple criteria simultaneously.
 * Returns a paginated collection of products matching the search criteria.
 *
 * **Personalization**: When authenticated (via optional Authorization header), the response includes
 * user-specific state for each product such as whether it's on the user's watchlist and notification preferences.
 * Anonymous requests receive product data without user state.
 *
 */
export const complexSearchProductsMutation = (options?: Partial<Options<ComplexSearchProductsData>>): UseMutationOptions<ComplexSearchProductsResponse, ComplexSearchProductsError, Options<ComplexSearchProductsData>> => {
    const mutationOptions: UseMutationOptions<ComplexSearchProductsResponse, ComplexSearchProductsError, Options<ComplexSearchProductsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await complexSearchProducts({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserSearchFiltersQueryKey = (options?: Options<GetUserSearchFiltersData>) => createQueryKey('getUserSearchFilters', options);

/**
 * List user search filters
 *
 * Retrieves all search filters for the authenticated user.
 * Results can be optionally sorted by creation date.
 * Requires valid Cognito JWT authentication.
 *
 */
export const getUserSearchFiltersOptions = (options?: Options<GetUserSearchFiltersData>) => queryOptions<GetUserSearchFiltersResponse, GetUserSearchFiltersError, GetUserSearchFiltersResponse, ReturnType<typeof getUserSearchFiltersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUserSearchFilters({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUserSearchFiltersQueryKey(options)
});

/**
 * Create a new search filter
 *
 * Creates a new search filter for the authenticated user.
 * The search filter configuration is provided in the request body.
 * Returns the created search filter with generated ID and metadata.
 * Requires valid Cognito JWT authentication.
 *
 */
export const createUserSearchFilterMutation = (options?: Partial<Options<CreateUserSearchFilterData>>): UseMutationOptions<CreateUserSearchFilterResponse, CreateUserSearchFilterError, Options<CreateUserSearchFilterData>> => {
    const mutationOptions: UseMutationOptions<CreateUserSearchFilterResponse, CreateUserSearchFilterError, Options<CreateUserSearchFilterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createUserSearchFilter({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a search filter
 *
 * Deletes a specific search filter by its ID for the authenticated user.
 * The search filter must exist and belong to the authenticated user.
 * Requires valid Cognito JWT authentication.
 *
 */
export const deleteUserSearchFilterMutation = (options?: Partial<Options<DeleteUserSearchFilterData>>): UseMutationOptions<DeleteUserSearchFilterResponse, DeleteUserSearchFilterError, Options<DeleteUserSearchFilterData>> => {
    const mutationOptions: UseMutationOptions<DeleteUserSearchFilterResponse, DeleteUserSearchFilterError, Options<DeleteUserSearchFilterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteUserSearchFilter({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserSearchFilterQueryKey = (options: Options<GetUserSearchFilterData>) => createQueryKey('getUserSearchFilter', options);

/**
 * Get a specific search filter
 *
 * Retrieves a specific search filter by its ID for the authenticated user.
 * Returns the complete search filter configuration and metadata.
 * Requires valid Cognito JWT authentication.
 *
 */
export const getUserSearchFilterOptions = (options: Options<GetUserSearchFilterData>) => queryOptions<GetUserSearchFilterResponse, GetUserSearchFilterError, GetUserSearchFilterResponse, ReturnType<typeof getUserSearchFilterQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUserSearchFilter({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUserSearchFilterQueryKey(options)
});

/**
 * Update a search filter
 *
 * Updates a specific search filter by its ID for the authenticated user.
 * Allows partial updates - only provided fields will be modified.
 * If no fields are provided in the request body, returns the existing search filter unchanged.
 * Requires valid Cognito JWT authentication.
 *
 */
export const updateUserSearchFilterMutation = (options?: Partial<Options<UpdateUserSearchFilterData>>): UseMutationOptions<UpdateUserSearchFilterResponse, UpdateUserSearchFilterError, Options<UpdateUserSearchFilterData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserSearchFilterResponse, UpdateUserSearchFilterError, Options<UpdateUserSearchFilterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateUserSearchFilter({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWatchlistProductsQueryKey = (options?: Options<GetWatchlistProductsData>) => createQueryKey('getWatchlistProducts', options);

/**
 * List user's watchlist products
 *
 * Retrieves all products in the authenticated user's watchlist.
 * Results are paginated using search-after cursor-based pagination with timestamp.
 * Requires valid Cognito JWT authentication.
 *
 */
export const getWatchlistProductsOptions = (options?: Options<GetWatchlistProductsData>) => queryOptions<GetWatchlistProductsResponse, GetWatchlistProductsError, GetWatchlistProductsResponse, ReturnType<typeof getWatchlistProductsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getWatchlistProducts({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getWatchlistProductsQueryKey(options)
});

/**
 * Add product to watchlist
 *
 * Adds an product to the authenticated user's watchlist.
 * The request body must contain the shop ID and shop's product ID.
 * Returns a 201 Created response with a Location header pointing to the created resource.
 * Requires valid Cognito JWT authentication.
 *
 */
export const addWatchlistProductMutation = (options?: Partial<Options<AddWatchlistProductData>>): UseMutationOptions<AddWatchlistProductResponse, AddWatchlistProductError, Options<AddWatchlistProductData>> => {
    const mutationOptions: UseMutationOptions<AddWatchlistProductResponse, AddWatchlistProductError, Options<AddWatchlistProductData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addWatchlistProduct({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserAccountQueryKey = (options?: Options<GetUserAccountData2>) => createQueryKey('getUserAccount', options);

/**
 * Get user account data
 *
 * Retrieves the authenticated user's account information including email, name, language, and currency preferences.
 * Requires valid Cognito JWT authentication.
 *
 */
export const getUserAccountOptions = (options?: Options<GetUserAccountData2>) => queryOptions<GetUserAccountResponse, GetUserAccountError, GetUserAccountResponse, ReturnType<typeof getUserAccountQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUserAccount({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUserAccountQueryKey(options)
});

/**
 * Update user account data
 *
 * Updates the authenticated user's account information.
 * All fields in the request body are optional - only provided fields will be updated.
 * Returns the updated user account data.
 * Requires valid Cognito JWT authentication.
 *
 */
export const updateUserAccountMutation = (options?: Partial<Options<UpdateUserAccountData>>): UseMutationOptions<UpdateUserAccountResponse, UpdateUserAccountError, Options<UpdateUserAccountData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserAccountResponse, UpdateUserAccountError, Options<UpdateUserAccountData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateUserAccount({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove product from watchlist
 *
 * Removes a specific product from the authenticated user's watchlist.
 * Returns a 204 No Content response on success.
 * Requires valid Cognito JWT authentication.
 *
 */
export const deleteWatchlistProductMutation = (options?: Partial<Options<DeleteWatchlistProductData>>): UseMutationOptions<DeleteWatchlistProductResponse, DeleteWatchlistProductError, Options<DeleteWatchlistProductData>> => {
    const mutationOptions: UseMutationOptions<DeleteWatchlistProductResponse, DeleteWatchlistProductError, Options<DeleteWatchlistProductData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteWatchlistProduct({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update watchlist product settings
 *
 * Updates settings for a specific watchlist product (e.g., toggle notifications).
 * Returns the updated watchlist product data with core identifiers and settings.
 * Requires valid Cognito JWT authentication.
 *
 */
export const patchWatchlistProductMutation = (options?: Partial<Options<PatchWatchlistProductData>>): UseMutationOptions<PatchWatchlistProductResponse, PatchWatchlistProductError, Options<PatchWatchlistProductData>> => {
    const mutationOptions: UseMutationOptions<PatchWatchlistProductResponse, PatchWatchlistProductError, Options<PatchWatchlistProductData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchWatchlistProduct({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a new shop
 *
 * Creates a new shop in the system with the provided details.
 * The shop must include at least one domain and can have up to 100 domains.
 * Returns the created shop with generated ID and timestamps.
 *
 */
export const createShopMutation = (options?: Partial<Options<CreateShopData>>): UseMutationOptions<CreateShopResponse, CreateShopError, Options<CreateShopData>> => {
    const mutationOptions: UseMutationOptions<CreateShopResponse, CreateShopError, Options<CreateShopData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createShop({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getShopQueryKey = (options: Options<GetShopData2>) => createQueryKey('getShop', options);

/**
 * Get shop details
 *
 * Retrieves detailed information about a specific shop by its identifier.
 * The identifier can be either a shop ID (UUID) or a domain associated with the shop.
 * Returns complete shop metadata including name, domains, image, and timestamps.
 *
 */
export const getShopOptions = (options: Options<GetShopData2>) => queryOptions<GetShopResponse, GetShopError, GetShopResponse, ReturnType<typeof getShopQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getShop({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getShopQueryKey(options)
});

/**
 * Update shop details
 *
 * Updates an existing shop's information by its identifier.
 * The identifier can be either a shop ID (UUID) or a domain associated with the shop.
 * All fields in the request body are optional - only provided fields will be updated.
 * If the request body is empty or only contains null values, the shop is returned unchanged.
 * When updating domains, the complete new set of domains must be provided.
 *
 */
export const updateShopMutation = (options?: Partial<Options<UpdateShopData>>): UseMutationOptions<UpdateShopResponse, UpdateShopError, Options<UpdateShopData>> => {
    const mutationOptions: UseMutationOptions<UpdateShopResponse, UpdateShopError, Options<UpdateShopData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateShop({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Search shops
 *
 * Performs an advanced search for shops using comprehensive filtering criteria.
 * This endpoint accepts a ShopSearchData object in the request body,
 * allowing for complex filtering by shop name and date ranges.
 * Returns a paginated collection of shops matching the search criteria.
 *
 */
export const searchShopsMutation = (options?: Partial<Options<SearchShopsData>>): UseMutationOptions<SearchShopsResponse, SearchShopsError, Options<SearchShopsData>> => {
    const mutationOptions: UseMutationOptions<SearchShopsResponse, SearchShopsError, Options<SearchShopsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await searchShops({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};
