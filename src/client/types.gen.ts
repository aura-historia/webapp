// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: (string & {});
};

/**
 * Complete item information including metadata and localized content
 */
export type GetItemData = {
    /**
     * Unique internal identifier for the item
     */
    itemId: string;
    /**
     * Unique identifier for the current state/version of the item
     */
    eventId: string;
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Shop's unique identifier for the item. Can be any arbitrary string.
     */
    shopsItemId: string;
    /**
     * Display name of the shop
     */
    shopName: string;
    title: LocalizedTextData;
    /**
     * Optional item description
     */
    description?: LocalizedTextData | null;
    /**
     * Optional item price
     */
    price?: PriceData | null;
    state: ItemStateData;
    /**
     * URL to the item on the shop's website
     */
    url: string;
    /**
     * Array of image URLs for the item
     */
    images: Array<string>;
    /**
     * When the item was first created (RFC3339 format)
     */
    created: string;
    /**
     * When the item was last updated (RFC3339 format)
     */
    updated: string;
    /**
     * Optional array of item history events
     */
    history?: Array<GetItemEventData> | null;
};

/**
 * Paginated collection of items using cursor-based pagination (search-after pattern)
 */
export type ItemSearchResultData = {
    /**
     * Array of items in the current page
     */
    items: Array<GetItemData>;
    /**
     * Number of items returned in the current page
     */
    size: number;
    /**
     * Total number of items matching the query (optional, may not always be available)
     */
    total?: number | null;
    /**
     * Cursor for the next page (JSON value). Present when there are more results.
     * Pass this value as the `searchAfter` query parameter to get the next page.
     * This can be ANY heterogeneous array.
     *
     */
    searchAfter?: Array<unknown> | null;
};

/**
 * Text content with language information
 */
export type LocalizedTextData = {
    /**
     * The text content
     */
    text: string;
    language: LanguageData;
};

/**
 * Price information with currency
 */
export type PriceData = {
    currency: CurrencyData;
    /**
     * Price amount in minor currency units (e.g., cents for EUR/USD)
     */
    amount: number;
};

/**
 * Minimal information about an item when it was created
 */
export type ItemCreatedEventPayloadData = {
    state: ItemStateData;
    price?: PriceData;
};

/**
 * Historical event for an item
 */
export type GetItemEventData = {
    eventType: ItemEventTypeData;
    /**
     * Unique internal identifier for the item
     */
    itemId: string;
    /**
     * Unique identifier for this event
     */
    eventId: string;
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Shop's unique identifier for the item. Can be any arbitrary string.
     */
    shopsItemId: string;
    payload: ItemEventPayloadData;
    /**
     * When the event occurred (RFC3339 format)
     */
    timestamp: string;
};

/**
 * Supported languages (ISO 639-1 codes):
 * - de: German (includes de-DE, de-AT, de-CH, de-LU, de-LI)
 * - en: English (includes en-US, en-GB, en-AU, en-CA, en-NZ, en-IE)
 * - fr: French (includes fr-FR, fr-CA, fr-BE, fr-CH, fr-LU)
 * - es: Spanish (includes es-ES, es-MX, es-AR, es-CO, es-CL, es-PE, es-VE)
 *
 */
export type LanguageData = 'de' | 'en' | 'fr' | 'es';

/**
 * Supported currencies (ISO 4217 codes):
 * - EUR: Euro
 * - GBP: British Pound
 * - USD: US Dollar
 * - AUD: Australian Dollar
 * - CAD: Canadian Dollar
 * - NZD: New Zealand Dollar
 *
 */
export type CurrencyData = 'EUR' | 'GBP' | 'USD' | 'AUD' | 'CAD' | 'NZD';

/**
 * Current state of the item:
 * - LISTED: Item has been listed
 * - AVAILABLE: Item is available for purchase
 * - RESERVED: Item is reserved by a buyer
 * - SOLD: Item has been sold
 * - REMOVED: Item has been removed and can no longer be tracked
 * - UNKNOWN: Item has an unknown state
 *
 */
export type ItemStateData = 'LISTED' | 'AVAILABLE' | 'RESERVED' | 'SOLD' | 'REMOVED' | 'UNKNOWN';

/**
 * Fields available for sorting:
 * - score: Sort by relevance score (default, only available when searching with text query)
 * - price: Sort by item price
 * - updated: Sort by last updated timestamp
 * - created: Sort by creation timestamp
 *
 */
export type SortItemFieldData = 'score' | 'price' | 'updated' | 'created';

/**
 * Types of events that can occur for an item
 */
export type ItemEventTypeData =
    'CREATED'
    | 'STATE_LISTED'
    | 'STATE_AVAILABLE'
    | 'STATE_RESERVED'
    | 'STATE_SOLD'
    | 'STATE_REMOVED'
    | 'STATE_UNKNOWN'
    | 'PRICE_DISCOVERED'
    | 'PRICE_DROPPED'
    | 'PRICE_INCREASED'
    | 'PRICE_REMOVED';

/**
 * Event-specific payload data
 */
export type ItemEventPayloadData = ItemCreatedEventPayloadData | ItemStateData | PriceData;

/**
 * Standard error response format
 */
export type ApiError = {
    /**
     * HTTP status code
     */
    status: number;
    /**
     * Error code identifier
     */
    error: string;
    source?: ApiErrorSource;
    /**
     * Human-readable error message
     */
    message?: string;
};

/**
 * Information about the source of the error
 */
export type ApiErrorSource = {
    /**
     * Name of the field that caused the error
     */
    field: string;
    /**
     * Type of parameter that caused the error
     */
    sourceType: 'query' | 'path' | 'header' | 'body';
};

/**
 * Search filter configuration with query parameters and filtering options
 */
export type SearchFilterData = {
    language: LanguageData;
    currency: CurrencyData;
    /**
     * Text query for searching items (minimum 3 characters)
     */
    itemQuery: string;
    /**
     * Optional text query for filtering by shop name
     */
    shopNameQuery?: string | null;
    /**
     * Optional price range filter in minor currency units
     */
    price?: RangeQueryUInt64 | null;
    /**
     * Optional filter by item states
     */
    state?: Array<ItemStateData> | null;
    /**
     * Optional filter by item creation date range
     */
    created?: RangeQueryDateTime | null;
    /**
     * Optional filter by item last updated date range
     */
    updated?: RangeQueryDateTime | null;
};

/**
 * Partial search filter update data.
 * All fields are optional and only provided fields will be updated.
 * Follows the same structure as SearchFilterData but with optional fields.
 *
 */
export type SearchFilterDataPatch = {
    /**
     * Language for search and localized content
     */
    language?: LanguageData | null;
    /**
     * Currency for price display
     */
    currency?: CurrencyData | null;
    /**
     * Text query for searching items (minimum 3 characters when provided)
     */
    itemQuery?: string | null;
    /**
     * Optional text query for filtering by shop name (minimum 3 characters when provided)
     */
    shopNameQuery?: string | null;
    /**
     * Optional price range filter in minor currency units
     */
    price?: RangeQueryUInt64 | null;
    /**
     * Optional filter by item states
     */
    state?: Array<ItemStateData> | null;
    /**
     * Optional filter by item creation date range
     */
    created?: RangeQueryDateTime | null;
    /**
     * Optional filter by item last updated date range
     */
    updated?: RangeQueryDateTime | null;
};

/**
 * Complete user search filter with metadata
 */
export type UserSearchFilterData = {
    /**
     * Unique identifier of the user who owns this search filter
     */
    userId: string;
    /**
     * Unique identifier for this search filter
     */
    searchFilterId: string;
    searchFilter: SearchFilterData;
    /**
     * When the search filter was created (RFC3339 format)
     */
    created: string;
    /**
     * When the search filter was last updated (RFC3339 format)
     */
    updated: string;
};

/**
 * Range query for numeric values (prices in minor currency units)
 */
export type RangeQueryUInt64 = {
    /**
     * Minimum value (inclusive)
     */
    min?: number;
    /**
     * Maximum value (inclusive)
     */
    max?: number;
};

/**
 * Range query for date and time values
 */
export type RangeQueryDateTime = {
    /**
     * Minimum date and time (inclusive, RFC3339 format)
     */
    min?: string;
    /**
     * Maximum date and time (inclusive, RFC3339 format)
     */
    max?: string;
};

/**
 * Fields available for sorting search filters:
 * - created: Sort by creation timestamp
 *
 */
export type SortSearchFilterFieldData = 'created';

/**
 * Paginated collection of user search filters with flattened pagination
 */
export type SearchFilterCollectionData = {
    /**
     * Array of search filters in the current page
     */
    items: Array<UserSearchFilterData>;
    /**
     * Number of items skipped (offset)
     */
    from: number;
    /**
     * Number of items in the current page
     */
    size: number;
    /**
     * Total number of items matching the query
     */
    total?: number | null;
};

/**
 * Collection of items to create or update
 */
export type PutItemsCollectionData = {
    /**
     * Array of items to process
     */
    items: Array<PutItemData>;
};

/**
 * Data required to create or update an item.
 * Shop information (shopId and shopName) is automatically enriched based on the item's URL.
 *
 */
export type PutItemData = {
    /**
     * Shop's unique identifier for the item. Can be any arbitrary string.
     */
    shopsItemId: string;
    title: LocalizedTextData;
    /**
     * Optional item description
     */
    description?: LocalizedTextData | null;
    /**
     * Optional item price
     */
    price?: PriceData | null;
    state: ItemStateData;
    /**
     * URL to the item on the shop's website.
     * The shop will be automatically identified and enriched based on this URL.
     *
     */
    url: string;
    /**
     * Array of image URLs for the item
     */
    images?: Array<string>;
};

/**
 * Response from bulk item creation/update operation with enrichment
 */
export type PutItemsResponse = {
    /**
     * Item URLs that could not be processed due to temporary issues.
     * These items may succeed if retried.
     *
     */
    unprocessed?: Array<string>;
    /**
     * Map of item URLs to error codes for items that failed processing.
     * The key is the item URL, and the value is the error code explaining why it failed.
     *
     */
    failed?: {
        [key: string]: PutItemError;
    };
    /**
     * Number of items that were skipped during processing because they had no changes
     */
    skipped: number;
};

/**
 * Complete shop information including metadata
 */
export type GetShopData = {
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Display name of the shop
     */
    name: string;
    /**
     * All known URLs to the shop's website
     */
    urls: Array<string>;
    /**
     * Optional URL to the shop's logo or image
     */
    image?: string | null;
    /**
     * When the shop was first created (RFC3339 format)
     */
    created: string;
    /**
     * When the shop was last updated (RFC3339 format)
     */
    updated: string;
};

/**
 * Search filter configuration for shops with query parameters and filtering options
 */
export type ShopSearchData = {
    /**
     * Optional text query for searching shops by name (minimum 3 characters)
     */
    shopNameQuery?: string;
    /**
     * Optional filter by shop creation date range
     */
    created?: RangeQueryDateTime | null;
    /**
     * Optional filter by shop last updated date range
     */
    updated?: RangeQueryDateTime | null;
};

/**
 * Fields available for sorting shops:
 * - score: Sort by relevance score (default, only available when searching with text query)
 * - name: Sort by shop name
 * - updated: Sort by last updated timestamp
 * - created: Sort by creation timestamp
 *
 */
export type SortShopFieldData = 'score' | 'name' | 'updated' | 'created';

/**
 * Paginated collection of shops with flattened pagination
 */
export type ShopSearchResultData = {
    /**
     * Array of shops in the current page
     */
    items: Array<GetShopData>;
    /**
     * Number of items skipped (offset)
     */
    from: number;
    /**
     * Number of items in the current page
     */
    size: number;
    /**
     * Total number of items matching the query
     */
    total?: number | null;
};

/**
 * Identifier for an item using shop ID and shop's item ID
 */
export type ItemKeyData = {
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Shop's unique identifier for the item. Can be any arbitrary string.
     */
    shopsItemId: string;
};

/**
 * Watchlist item containing the item data and when it was added to the watchlist
 */
export type WatchlistItemData = {
    item: GetItemData;
    /**
     * When the item was added to the watchlist (RFC3339 format)
     */
    created: string;
};

/**
 * Paginated collection of watchlist items using cursor-based pagination
 */
export type WatchlistCollectionData = {
    /**
     * Array of watchlist items in the current page
     */
    items: Array<WatchlistItemData>;
    /**
     * Number of items in the current page
     */
    size: number;
    /**
     * Cursor for the next page (RFC3339 timestamp). Present when there are more results.
     */
    searchAfter?: string | null;
    /**
     * Total number of items (optional, may not be available for cursor-based pagination)
     */
    total?: number | null;
};

/**
 * Fields available for sorting watchlist items:
 * - created: Sort by when item was added to watchlist
 *
 */
export type SortWatchlistItemFieldData = 'created';

/**
 * Error codes for items that failed during processing:
 * - SHOP_NOT_FOUND: The shop associated with the item's URL is not registered in the system
 * - MONETARY_AMOUNT_OVERFLOW: The price amount exceeds the maximum supported value during currency conversion
 * - ITEM_ENRICHMENT_FAILED: Failed to enrich the item with additional shop and price information
 *
 */
export type PutItemError = 'SHOP_NOT_FOUND' | 'MONETARY_AMOUNT_OVERFLOW' | 'ITEM_ENRICHMENT_FAILED';

export type GetItemData2 = {
    body?: never;
    headers?: {
        /**
         * Preferred language for localized content.
         * Supports quality values and multiple languages.
         * Supported languages: de, en, fr, es (with regional variants).
         *
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * Unique identifier of the shop
         */
        shopId: string;
        /**
         * Shop's unique identifier for the item. Can be any arbitrary string.
         */
        shopsItemId: string;
    };
    query?: {
        /**
         * Currency for price display
         */
        currency?: CurrencyData;
        /**
         * Whether to include item history in the response
         */
        history?: boolean;
    };
    url: '/api/v1/items/{shopId}/{shopsItemId}';
};

export type GetItemErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Item not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetItemError = GetItemErrors[keyof GetItemErrors];

export type GetItemResponses = {
    /**
     * Item found and returned successfully
     */
    200: GetItemData;
};

export type GetItemResponse = GetItemResponses[keyof GetItemResponses];

export type SearchItemsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Text search query (minimum 3 characters)
         */
        q: string;
        /**
         * Language for search and localized content
         */
        language?: LanguageData;
        /**
         * Currency for price display
         */
        currency?: CurrencyData;
        /**
         * Field to sort results by
         */
        sort?: SortItemFieldData;
        /**
         * Sort order (only valid when sort is specified)
         */
        order?: 'asc' | 'desc';
        /**
         * Cursor value for pagination (search-after pattern).
         * This is a JSON value returned as `searchAfter` in the previous response.
         * Use this to fetch the next page of results.
         * In general you do not have to worry about determining this key. It's given with the `searchAfter` field in the preceding response if more entries are present.
         * This can be ANY heterogeneous array.
         *
         */
        searchAfter?: Array<unknown>;
        /**
         * Number of items to return per page
         */
        size?: number;
    };
    url: '/api/v1/items';
};

export type SearchItemsErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type SearchItemsError = SearchItemsErrors[keyof SearchItemsErrors];

export type SearchItemsResponses = {
    /**
     * Search results returned successfully
     */
    200: ItemSearchResultData;
};

export type SearchItemsResponse = SearchItemsResponses[keyof SearchItemsResponses];

export type PutItemsData = {
    /**
     * Collection of items to create or update
     */
    body: PutItemsCollectionData;
    path?: never;
    query?: never;
    url: '/api/v1/items';
};

export type PutItemsErrors = {
    /**
     * Bad request - invalid request body
     */
    400: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type PutItemsError = PutItemsErrors[keyof PutItemsErrors];

export type PutItemsResponses = {
    /**
     * Items processed successfully
     */
    200: PutItemsResponse;
};

export type PutItemsResponse2 = PutItemsResponses[keyof PutItemsResponses];

export type ComplexSearchItemsData = {
    /**
     * Search filter configuration with all filtering criteria.
     * Unlike the simple text search, this allows filtering by multiple fields,
     * price ranges, item states, and date ranges.
     *
     */
    body: SearchFilterData;
    path?: never;
    query?: {
        /**
         * Field to sort results by
         */
        sort?: SortItemFieldData;
        /**
         * Sort order (only valid when sort is specified)
         */
        order?: 'asc' | 'desc';
        /**
         * Cursor value for pagination (search-after pattern).
         * This is a JSON value returned as `searchAfter` in the previous response.
         * Use this to fetch the next page of results.
         * In general you do not have to worry about determining this key. It's given with the `searchAfter` field in the preceding response if more entries are present.
         * This can be ANY heterogeneous array.
         *
         */
        searchAfter?: Array<unknown>;
        /**
         * Number of items to return per page
         */
        size?: number;
    };
    url: '/api/v1/items/search';
};

export type ComplexSearchItemsErrors = {
    /**
     * Bad request - invalid parameters or body
     */
    400: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type ComplexSearchItemsError = ComplexSearchItemsErrors[keyof ComplexSearchItemsErrors];

export type ComplexSearchItemsResponses = {
    /**
     * Complex search results returned successfully
     */
    200: ItemSearchResultData;
};

export type ComplexSearchItemsResponse = ComplexSearchItemsResponses[keyof ComplexSearchItemsResponses];

export type GetSearchFiltersData = {
    body?: never;
    headers: {
        /**
         * Cognito JWT token for user authentication
         */
        Authorization: string;
    };
    path?: never;
    query?: {
        /**
         * Field to sort results by
         */
        sort?: SortSearchFilterFieldData;
        /**
         * Sort order (only valid when sort is specified)
         */
        order?: 'asc' | 'desc';
    };
    url: '/api/v1/search-filters';
};

export type GetSearchFiltersErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetSearchFiltersError = GetSearchFiltersErrors[keyof GetSearchFiltersErrors];

export type GetSearchFiltersResponses = {
    /**
     * Search filters retrieved successfully
     */
    200: SearchFilterCollectionData;
};

export type GetSearchFiltersResponse = GetSearchFiltersResponses[keyof GetSearchFiltersResponses];

export type CreateSearchFilterData = {
    /**
     * Search filter configuration
     */
    body: SearchFilterData;
    headers: {
        /**
         * Cognito JWT token for user authentication
         */
        Authorization: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/search-filters';
};

export type CreateSearchFilterErrors = {
    /**
     * Bad request - invalid request body
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type CreateSearchFilterError = CreateSearchFilterErrors[keyof CreateSearchFilterErrors];

export type CreateSearchFilterResponses = {
    /**
     * Search filter created successfully
     */
    201: UserSearchFilterData;
};

export type CreateSearchFilterResponse = CreateSearchFilterResponses[keyof CreateSearchFilterResponses];

export type DeleteSearchFilterData = {
    body?: never;
    headers: {
        /**
         * Cognito JWT token for user authentication
         */
        Authorization: string;
    };
    path: {
        /**
         * Unique identifier of the search filter to delete
         */
        searchFilterId: string;
    };
    query?: never;
    url: '/api/v1/search-filters/{searchFilterId}';
};

export type DeleteSearchFilterErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Search filter not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type DeleteSearchFilterError = DeleteSearchFilterErrors[keyof DeleteSearchFilterErrors];

export type DeleteSearchFilterResponses = {
    /**
     * Search filter deleted successfully
     */
    204: void;
};

export type DeleteSearchFilterResponse = DeleteSearchFilterResponses[keyof DeleteSearchFilterResponses];

export type GetSearchFilterData = {
    body?: never;
    headers: {
        /**
         * Cognito JWT token for user authentication
         */
        Authorization: string;
    };
    path: {
        /**
         * Unique identifier of the search filter
         */
        searchFilterId: string;
    };
    query?: never;
    url: '/api/v1/search-filters/{searchFilterId}';
};

export type GetSearchFilterErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Search filter not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetSearchFilterError = GetSearchFilterErrors[keyof GetSearchFilterErrors];

export type GetSearchFilterResponses = {
    /**
     * Search filter found and returned successfully
     */
    200: UserSearchFilterData;
};

export type GetSearchFilterResponse = GetSearchFilterResponses[keyof GetSearchFilterResponses];

export type UpdateSearchFilterData = {
    /**
     * Partial search filter update data.
     * Only provided fields will be updated. If body is empty, returns existing filter.
     *
     */
    body?: SearchFilterDataPatch;
    headers: {
        /**
         * Cognito JWT token for user authentication
         */
        Authorization: string;
    };
    path: {
        /**
         * Unique identifier of the search filter to update
         */
        searchFilterId: string;
    };
    query?: never;
    url: '/api/v1/search-filters/{searchFilterId}';
};

export type UpdateSearchFilterErrors = {
    /**
     * Bad request - invalid parameters or body
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Search filter not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type UpdateSearchFilterError = UpdateSearchFilterErrors[keyof UpdateSearchFilterErrors];

export type UpdateSearchFilterResponses = {
    /**
     * Search filter updated successfully
     */
    200: UserSearchFilterData;
};

export type UpdateSearchFilterResponse = UpdateSearchFilterResponses[keyof UpdateSearchFilterResponses];

export type GetWatchlistItemsData = {
    body?: never;
    headers: {
        /**
         * Preferred language for localized content.
         * Supports quality values and multiple languages.
         * Supported languages: de, en, fr, es (with regional variants).
         *
         */
        'Accept-Language'?: string;
        /**
         * Cognito JWT token for user authentication
         */
        Authorization: string;
    };
    path?: never;
    query?: {
        /**
         * Currency for price display
         */
        currency?: CurrencyData;
        /**
         * Field to sort results by
         */
        sort?: SortWatchlistItemFieldData;
        /**
         * Sort order (only valid when sort is specified)
         */
        order?: 'asc' | 'desc';
        /**
         * RFC3339 timestamp for cursor-based pagination (search-after).
         * Depending on sort-order, returns watchlist-items created, either after this timestamp for asc (oldest first) or before this timestamp for desc (latest first).
         * In general you do not have to worry about determining this key. It's given with `searchAfter` in the preceding response if more entries are present.
         *
         */
        searchAfter?: string;
        /**
         * Number of items to return per page
         */
        size?: number;
    };
    url: '/api/v1/watchlist';
};

export type GetWatchlistItemsErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetWatchlistItemsError = GetWatchlistItemsErrors[keyof GetWatchlistItemsErrors];

export type GetWatchlistItemsResponses = {
    /**
     * Watchlist items retrieved successfully
     */
    200: WatchlistCollectionData;
};

export type GetWatchlistItemsResponse = GetWatchlistItemsResponses[keyof GetWatchlistItemsResponses];

export type AddWatchlistItemData = {
    /**
     * Item identifier to add to watchlist
     */
    body: ItemKeyData;
    headers: {
        /**
         * Cognito JWT token for user authentication
         */
        Authorization: string;
    };
    path?: never;
    query?: never;
    url: '/api/v1/watchlist';
};

export type AddWatchlistItemErrors = {
    /**
     * Bad request - invalid request body
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type AddWatchlistItemError = AddWatchlistItemErrors[keyof AddWatchlistItemErrors];

export type AddWatchlistItemResponses = {
    /**
     * Item added to watchlist successfully
     */
    201: unknown;
};

export type DeleteWatchlistItemData = {
    body?: never;
    headers: {
        /**
         * Cognito JWT token for user authentication
         */
        Authorization: string;
    };
    path: {
        /**
         * Unique identifier of the shop
         */
        shopId: string;
        /**
         * Shop's unique identifier for the item
         */
        shopsItemId: string;
    };
    query: {
        /**
         * RFC3339 timestamp of when the watchlist entry was created.
         * Required to identify the exact entry to delete.
         *
         */
        created: string;
    };
    url: '/api/v1/watchlist/{shopId}/{shopsItemId}';
};

export type DeleteWatchlistItemErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Watchlist entry not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type DeleteWatchlistItemError = DeleteWatchlistItemErrors[keyof DeleteWatchlistItemErrors];

export type DeleteWatchlistItemResponses = {
    /**
     * Item removed from watchlist successfully
     */
    204: void;
};

export type DeleteWatchlistItemResponse = DeleteWatchlistItemResponses[keyof DeleteWatchlistItemResponses];

export type GetShopData2 = {
    body?: never;
    path: {
        /**
         * Unique identifier of the shop
         */
        shopId: string;
    };
    query?: never;
    url: '/api/v1/shops/{shopId}';
};

export type GetShopErrors = {
    /**
     * Bad request - invalid shop ID
     */
    400: ApiError;
    /**
     * Shop not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetShopError = GetShopErrors[keyof GetShopErrors];

export type GetShopResponses = {
    /**
     * Shop found and returned successfully
     */
    200: GetShopData;
};

export type GetShopResponse = GetShopResponses[keyof GetShopResponses];

export type SearchShopsData = {
    /**
     * Shop search filter configuration with all filtering criteria.
     * Allows filtering by shop name and creation/update date ranges.
     * If you do not want to restrict the search, supply an empty JSON-Object '{}' as body.
     *
     */
    body: ShopSearchData;
    path?: never;
    query?: {
        /**
         * Field to sort results by
         */
        sort?: SortShopFieldData;
        /**
         * Sort order (only valid when sort is specified)
         */
        order?: 'asc' | 'desc';
        /**
         * Pagination offset (number of shops to skip)
         */
        from?: number;
        /**
         * Number of shops to return per page
         */
        size?: number;
    };
    url: '/api/v1/shops/search';
};

export type SearchShopsErrors = {
    /**
     * Bad request - invalid parameters or body
     */
    400: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type SearchShopsError = SearchShopsErrors[keyof SearchShopsErrors];

export type SearchShopsResponses = {
    /**
     * Shop search results returned successfully
     */
    200: ShopSearchResultData;
};

export type SearchShopsResponse = SearchShopsResponses[keyof SearchShopsResponses];
