// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: "https://api.blitzfilter.com" | (string & {});
};

/**
 * Complete item information including metadata and localized content
 */
export type GetItemData = {
    /**
     * Unique internal identifier for the item
     */
    itemId: string;
    /**
     * Unique identifier for the current state/version of the item
     */
    eventId: string;
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Shop's unique identifier for the item
     */
    shopsItemId: string;
    /**
     * Display name of the shop
     */
    shopName: string;
    title: LocalizedTextData;
    /**
     * Optional item description
     */
    description?: LocalizedTextData | null;
    /**
     * Optional item price
     */
    price?: PriceData | null;
    state: ItemStateData;
    /**
     * URL to the item on the shop's website
     */
    url: string;
    /**
     * Array of image URLs for the item
     */
    images: Array<string>;
    /**
     * When the item was first created (RFC3339 format)
     */
    created: string;
    /**
     * When the item was last updated (RFC3339 format)
     */
    updated: string;
    /**
     * Optional array of item history events
     */
    history?: Array<GetItemEventData> | null;
};

/**
 * Paginated collection of items
 */
export type CollectionData = {
    /**
     * Array of items in the current page
     */
    items: Array<GetItemData>;
    pagination: PaginationData;
};

/**
 * Pagination metadata
 */
export type PaginationData = {
    /**
     * Number of items skipped (offset)
     */
    from: number;
    /**
     * Number of items in the current page
     */
    size: number;
    /**
     * Total number of items matching the query
     */
    total: number;
};

/**
 * Text content with language information
 */
export type LocalizedTextData = {
    /**
     * The text content
     */
    text: string;
    language: LanguageData;
};

/**
 * Price information with currency
 */
export type PriceData = {
    currency: CurrencyData;
    /**
     * Price amount in minor currency units (e.g., cents for EUR/USD)
     */
    amount: number;
};

/**
 * Historical event for an item
 */
export type GetItemEventData = {
    eventType: ItemEventTypeData;
    /**
     * Unique internal identifier for the item
     */
    itemId: string;
    /**
     * Unique identifier for this event
     */
    eventId: string;
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Shop's unique identifier for the item
     */
    shopsItemId: string;
    payload: ItemEventPayloadData;
    /**
     * When the event occurred (RFC3339 format)
     */
    timestamp: string;
};

/**
 * Supported languages (ISO 639-1 codes):
 * - de: German (includes de-DE, de-AT, de-CH, de-LU, de-LI)
 * - en: English (includes en-US, en-GB, en-AU, en-CA, en-NZ, en-IE)
 * - fr: French (includes fr-FR, fr-CA, fr-BE, fr-CH, fr-LU)
 * - es: Spanish (includes es-ES, es-MX, es-AR, es-CO, es-CL, es-PE, es-VE)
 *
 */
export type LanguageData = "de" | "en" | "fr" | "es";

/**
 * Supported currencies (ISO 4217 codes):
 * - EUR: Euro
 * - GBP: British Pound
 * - USD: US Dollar
 * - AUD: Australian Dollar
 * - CAD: Canadian Dollar
 * - NZD: New Zealand Dollar
 *
 */
export type CurrencyData = "EUR" | "GBP" | "USD" | "AUD" | "CAD" | "NZD";

/**
 * Current state of the item:
 * - LISTED: Item has been listed
 * - AVAILABLE: Item is available for purchase
 * - RESERVED: Item is reserved by a buyer
 * - SOLD: Item has been sold
 * - REMOVED: Item has been removed and can no longer be tracked
 *
 */
export type ItemStateData = "LISTED" | "AVAILABLE" | "RESERVED" | "SOLD" | "REMOVED";

/**
 * Fields available for sorting:
 * - price: Sort by item price
 * - updated: Sort by last updated timestamp
 * - created: Sort by creation timestamp
 *
 */
export type SortItemFieldData = "price" | "updated" | "created";

/**
 * Types of events that can occur for an item
 */
export type ItemEventTypeData =
    | "STATE_AVAILABLE"
    | "PRICE_DROPPED"
    | "STATE_LISTED"
    | "STATE_RESERVED"
    | "STATE_SOLD"
    | "STATE_REMOVED";

/**
 * Event-specific payload data
 */
export type ItemEventPayloadData = ItemStateData | PriceData;

/**
 * Standard error response format
 */
export type ApiError = {
    /**
     * HTTP status code
     */
    status: number;
    /**
     * Error code identifier
     */
    error: string;
    source?: ApiErrorSource;
    /**
     * Human-readable error message
     */
    message?: string;
};

/**
 * Information about the source of the error
 */
export type ApiErrorSource = {
    /**
     * Name of the field that caused the error
     */
    field: string;
    /**
     * Type of parameter that caused the error
     */
    sourceType: "query" | "path" | "header" | "body";
};

/**
 * Search filter configuration with query parameters and filtering options
 */
export type SearchFilterData = {
    language: LanguageData;
    currency: CurrencyData;
    /**
     * Text query for searching items (minimum 3 characters)
     */
    itemQuery: string;
    /**
     * Optional text query for filtering by shop name
     */
    shopNameQuery?: string | null;
    /**
     * Optional price range filter in minor currency units
     */
    price?: RangeQueryUInt64 | null;
    /**
     * Optional filter by item states
     */
    state?: Array<ItemStateData>;
    /**
     * Optional filter by item creation date range
     */
    created?: RangeQueryDateTime | null;
    /**
     * Optional filter by item last updated date range
     */
    updated?: RangeQueryDateTime | null;
};

/**
 * Partial search filter update data.
 * All fields are optional and only provided fields will be updated.
 * Follows the same structure as SearchFilterData but with optional fields.
 *
 */
export type SearchFilterDataPatch = {
    /**
     * Language for search and localized content
     */
    language?: LanguageData | null;
    /**
     * Currency for price display
     */
    currency?: CurrencyData | null;
    /**
     * Text query for searching items (minimum 3 characters when provided)
     */
    itemQuery?: string | null;
    /**
     * Optional text query for filtering by shop name (minimum 3 characters when provided)
     */
    shopNameQuery?: string | null;
    /**
     * Optional price range filter in minor currency units
     */
    price?: RangeQueryUInt64 | null;
    /**
     * Optional filter by item states
     */
    state?: Array<ItemStateData> | null;
    /**
     * Optional filter by item creation date range
     */
    created?: RangeQueryDateTime | null;
    /**
     * Optional filter by item last updated date range
     */
    updated?: RangeQueryDateTime | null;
};

/**
 * Complete user search filter with metadata
 */
export type UserSearchFilterData = {
    /**
     * Unique identifier of the user who owns this search filter
     */
    userId: string;
    /**
     * Unique identifier for this search filter
     */
    searchFilterId: string;
    searchFilter: SearchFilterData;
    /**
     * When the search filter was created (RFC3339 format)
     */
    created: string;
    /**
     * When the search filter was last updated (RFC3339 format)
     */
    updated: string;
};

/**
 * Range query for numeric values (prices in minor currency units)
 */
export type RangeQueryUInt64 = {
    /**
     * Minimum value (inclusive)
     */
    min?: number;
    /**
     * Maximum value (inclusive)
     */
    max?: number;
};

/**
 * Range query for date and time values
 */
export type RangeQueryDateTime = {
    /**
     * Minimum date and time (inclusive, RFC3339 format)
     */
    min?: string;
    /**
     * Maximum date and time (inclusive, RFC3339 format)
     */
    max?: string;
};

/**
 * Fields available for sorting search filters:
 * - created: Sort by creation timestamp
 *
 */
export type SortSearchFilterFieldData = "created";

/**
 * Paginated collection of user search filters
 */
export type CollectionDataUserSearchFilter = {
    /**
     * Array of search filters in the current page
     */
    items: Array<UserSearchFilterData>;
    pagination: PaginationData;
};

export type GetItemData2 = {
    body?: never;
    headers?: {
        /**
         * Preferred language for localized content.
         * Supports quality values and multiple languages.
         * Supported languages: de, en, fr, es (with regional variants).
         *
         */
        "Accept-Language"?: string;
    };
    path: {
        /**
         * Unique identifier of the shop
         */
        shopId: string;
        /**
         * Shop's unique identifier for the item
         */
        shopsItemId: string;
    };
    query?: {
        /**
         * Currency for price display
         */
        currency?: CurrencyData;
        /**
         * Whether to include item history in the response
         */
        history?: boolean;
    };
    url: "/api/v1/items/{shopId}/{shopsItemId}";
};

export type GetItemErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Item not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetItemError = GetItemErrors[keyof GetItemErrors];

export type GetItemResponses = {
    /**
     * Item found and returned successfully
     */
    200: GetItemData;
};

export type GetItemResponse = GetItemResponses[keyof GetItemResponses];

export type SearchItemsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Text search query (minimum 3 characters)
         */
        q: string;
        /**
         * Language for search and localized content
         */
        language?: LanguageData;
        /**
         * Currency for price display
         */
        currency?: CurrencyData;
        /**
         * Field to sort results by
         */
        sort?: SortItemFieldData;
        /**
         * Sort order (only valid when sort is specified)
         */
        order?: "asc" | "desc";
        /**
         * Pagination offset (number of items to skip)
         */
        from?: number;
        /**
         * Number of items to return per page
         */
        size?: number;
    };
    url: "/api/v1/items";
};

export type SearchItemsErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type SearchItemsError = SearchItemsErrors[keyof SearchItemsErrors];

export type SearchItemsResponses = {
    /**
     * Search results returned successfully
     */
    200: CollectionData;
};

export type SearchItemsResponse = SearchItemsResponses[keyof SearchItemsResponses];

export type ComplexSearchItemsData = {
    /**
     * Search filter configuration with all filtering criteria.
     * Unlike the simple text search, this allows filtering by multiple fields,
     * price ranges, item states, and date ranges.
     *
     */
    body: SearchFilterData;
    path?: never;
    query?: {
        /**
         * Field to sort results by
         */
        sort?: SortItemFieldData;
        /**
         * Sort order (only valid when sort is specified)
         */
        order?: "asc" | "desc";
        /**
         * Pagination offset (number of items to skip)
         */
        from?: number;
        /**
         * Number of items to return per page
         */
        size?: number;
    };
    url: "/api/v1/items/search";
};

export type ComplexSearchItemsErrors = {
    /**
     * Bad request - invalid parameters or body
     */
    400: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type ComplexSearchItemsError = ComplexSearchItemsErrors[keyof ComplexSearchItemsErrors];

export type ComplexSearchItemsResponses = {
    /**
     * Complex search results returned successfully
     */
    200: CollectionData;
};

export type ComplexSearchItemsResponse =
    ComplexSearchItemsResponses[keyof ComplexSearchItemsResponses];

export type GetSearchFiltersData = {
    body?: never;
    headers: {
        /**
         * Cognito JWT token for user authentication
         */
        Authorization: string;
    };
    path?: never;
    query?: {
        /**
         * Field to sort results by
         */
        sort?: SortSearchFilterFieldData;
        /**
         * Sort order (only valid when sort is specified)
         */
        order?: "asc" | "desc";
    };
    url: "/api/v1/search-filters";
};

export type GetSearchFiltersErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetSearchFiltersError = GetSearchFiltersErrors[keyof GetSearchFiltersErrors];

export type GetSearchFiltersResponses = {
    /**
     * Search filters retrieved successfully
     */
    200: CollectionDataUserSearchFilter;
};

export type GetSearchFiltersResponse = GetSearchFiltersResponses[keyof GetSearchFiltersResponses];

export type CreateSearchFilterData = {
    /**
     * Search filter configuration
     */
    body: SearchFilterData;
    headers: {
        /**
         * Cognito JWT token for user authentication
         */
        Authorization: string;
    };
    path?: never;
    query?: never;
    url: "/api/v1/search-filters";
};

export type CreateSearchFilterErrors = {
    /**
     * Bad request - invalid request body
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type CreateSearchFilterError = CreateSearchFilterErrors[keyof CreateSearchFilterErrors];

export type CreateSearchFilterResponses = {
    /**
     * Search filter created successfully
     */
    201: UserSearchFilterData;
};

export type CreateSearchFilterResponse =
    CreateSearchFilterResponses[keyof CreateSearchFilterResponses];

export type DeleteSearchFilterData = {
    body?: never;
    headers: {
        /**
         * Cognito JWT token for user authentication
         */
        Authorization: string;
    };
    path: {
        /**
         * Unique identifier of the search filter to delete
         */
        searchFilterId: string;
    };
    query?: never;
    url: "/api/v1/search-filters/{searchFilterId}";
};

export type DeleteSearchFilterErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Search filter not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type DeleteSearchFilterError = DeleteSearchFilterErrors[keyof DeleteSearchFilterErrors];

export type DeleteSearchFilterResponses = {
    /**
     * Search filter deleted successfully
     */
    204: void;
};

export type DeleteSearchFilterResponse =
    DeleteSearchFilterResponses[keyof DeleteSearchFilterResponses];

export type GetSearchFilterData = {
    body?: never;
    headers: {
        /**
         * Cognito JWT token for user authentication
         */
        Authorization: string;
    };
    path: {
        /**
         * Unique identifier of the search filter
         */
        searchFilterId: string;
    };
    query?: never;
    url: "/api/v1/search-filters/{searchFilterId}";
};

export type GetSearchFilterErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Search filter not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetSearchFilterError = GetSearchFilterErrors[keyof GetSearchFilterErrors];

export type GetSearchFilterResponses = {
    /**
     * Search filter found and returned successfully
     */
    200: UserSearchFilterData;
};

export type GetSearchFilterResponse = GetSearchFilterResponses[keyof GetSearchFilterResponses];

export type UpdateSearchFilterData = {
    /**
     * Partial search filter update data.
     * Only provided fields will be updated. If body is empty, returns existing filter.
     *
     */
    body?: SearchFilterDataPatch;
    headers: {
        /**
         * Cognito JWT token for user authentication
         */
        Authorization: string;
    };
    path: {
        /**
         * Unique identifier of the search filter to update
         */
        searchFilterId: string;
    };
    query?: never;
    url: "/api/v1/search-filters/{searchFilterId}";
};

export type UpdateSearchFilterErrors = {
    /**
     * Bad request - invalid parameters or body
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Search filter not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type UpdateSearchFilterError = UpdateSearchFilterErrors[keyof UpdateSearchFilterErrors];

export type UpdateSearchFilterResponses = {
    /**
     * Search filter updated successfully
     */
    200: UserSearchFilterData;
};

export type UpdateSearchFilterResponse =
    UpdateSearchFilterResponses[keyof UpdateSearchFilterResponses];
