// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://api.dev.aura-historia.com' | (string & {});
};

/**
 * Complete product information including metadata and localized content
 */
export type GetProductData = {
    /**
     * Unique internal identifier for the product
     */
    productId: string;
    /**
     * Human-readable slug identifier for the product (kebab-case with 6-character hex suffix).
     * Format: {product-title}-{6-char-hex} where the title is derived from the product name.
     * Example: "amazing-product-fa87c4"
     *
     */
    productSlugId: string;
    /**
     * Human-readable slug identifier of the shop (kebab-case, derived from shop name).
     * Example: "tech-store-premium" or "christies"
     *
     */
    shopSlugId: string;
    /**
     * Unique identifier for the current state/version of the product
     */
    eventId: string;
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Shop's unique identifier for the product. Can be any arbitrary string.
     */
    shopsProductId: string;
    /**
     * Display name of the shop
     */
    shopName: string;
    shopType: ShopTypeData;
    title: LocalizedTextData;
    /**
     * Optional product description
     */
    description?: LocalizedTextData | null;
    /**
     * Optional product price
     */
    price?: PriceData | null;
    /**
     * Optional minimum estimated price for the product
     */
    priceEstimateMin?: PriceData | null;
    /**
     * Optional maximum estimated price for the product
     */
    priceEstimateMax?: PriceData | null;
    state: ProductStateData;
    /**
     * URL to the product on the shop's website
     */
    url: string;
    /**
     * Array of product images with prohibited content classification
     */
    images: Array<ProductImageData>;
    /**
     * Lower end of the year range when the antique is estimated to have originated.
     * Only present when the origin year is expressed as a range (originYear will be null).
     * Can be present alone (without originYearMax) to indicate "after this year".
     *
     */
    originYearMin?: number | null;
    /**
     * Exact year the antique is estimated to have originated.
     * When this value is present, both originYearMin and originYearMax will be null.
     *
     */
    originYear?: number | null;
    /**
     * Upper end of the year range when the antique is estimated to have originated.
     * Only present when the origin year is expressed as a range (originYear will be null).
     * Can be present alone (without originYearMin) to indicate "before this year".
     *
     */
    originYearMax?: number | null;
    /**
     * Authenticity classification of the antique product
     */
    authenticity?: AuthenticityData | null;
    /**
     * Physical condition assessment of the antique product
     */
    condition?: ConditionData | null;
    /**
     * Documentation trail and ownership history of the antique product
     */
    provenance?: ProvenanceData | null;
    /**
     * Level of restoration work performed on the antique product
     */
    restoration?: RestorationData | null;
    /**
     * Start datetime of the auction window for this product (RFC3339 format).
     * Only present for products from auction houses with scheduled auction times.
     * Used to indicate when bidding begins or when the item will be auctioned.
     *
     */
    auctionStart?: string | null;
    /**
     * End datetime of the auction window for this product (RFC3339 format).
     * Only present for products from auction houses with scheduled auction times.
     * Used to indicate when bidding ends or when the auction session concludes.
     *
     */
    auctionEnd?: string | null;
    /**
     * When the product was first created (RFC3339 format)
     */
    created: string;
    /**
     * When the product was last updated (RFC3339 format)
     */
    updated: string;
};

/**
 * Lightweight product summary information for use in search results and similar products listings.
 * Contains essential product details without extended metadata fields like description, estimates,
 * origin year details, authenticity, condition, provenance, restoration, auction times, or history.
 *
 */
export type GetProductSummaryData = {
    /**
     * Unique internal identifier for the product
     */
    productId: string;
    /**
     * Human-readable slug identifier for the product (kebab-case with 6-character hex suffix).
     * Format: {product-title}-{6-char-hex} where the title is derived from the product name.
     * Example: "amazing-product-fa87c4"
     *
     */
    productSlugId: string;
    /**
     * Human-readable slug identifier of the shop (kebab-case, derived from shop name).
     * Example: "tech-store-premium" or "christies"
     *
     */
    shopSlugId: string;
    /**
     * Unique identifier for the current state/version of the product
     */
    eventId: string;
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Shop's unique identifier for the product. Can be any arbitrary string.
     */
    shopsProductId: string;
    /**
     * Display name of the shop
     */
    shopName: string;
    shopType: ShopTypeData;
    title: LocalizedTextData;
    /**
     * Optional product price
     */
    price?: PriceData | null;
    state: ProductStateData;
    /**
     * URL to the product on the shop's website
     */
    url: string;
    /**
     * Array of product images with prohibited content classification
     */
    images: Array<ProductImageData>;
    /**
     * When the product was first created (RFC3339 format)
     */
    created: string;
    /**
     * When the product was last updated (RFC3339 format)
     */
    updated: string;
};

/**
 * Wrapper for product data with optional user-specific state.
 * When user is authenticated, includes personalized information such as watchlist status.
 * When user is anonymous, only the product data is present.
 *
 */
export type PersonalizedGetProductData = {
    item: GetProductData;
    /**
     * Optional user-specific state for this product (only present when authenticated)
     */
    userState?: ProductUserStateData | null;
};

/**
 * Wrapper for lightweight product summary data with optional user-specific state.
 * Used in search results and similar products listings.
 * When user is authenticated, includes personalized information such as watchlist status.
 * When user is anonymous, only the product summary data is present.
 *
 */
export type PersonalizedGetProductSummaryData = {
    item: GetProductSummaryData;
    /**
     * Optional user-specific state for this product (only present when authenticated)
     */
    userState?: ProductUserStateData | null;
};

/**
 * Paginated collection of personalized products using cursor-based pagination (search-after pattern).
 * Each product may include user-specific state when the request is authenticated.
 *
 */
export type PersonalizedProductSearchResultData = {
    /**
     * Array of personalized product summaries in the current page
     */
    items: Array<PersonalizedGetProductSummaryData>;
    /**
     * Number of products returned in the current page
     */
    size: number;
    /**
     * Total number of products matching the query (optional, may not always be available)
     */
    total?: number | null;
    /**
     * Cursor for the next page (JSON value). Present when there are more results.
     * Pass this value as the `searchAfter` query parameter to get the next page.
     * This can be ANY heterogeneous array.
     *
     */
    searchAfter?: Array<unknown> | null;
};

/**
 * User-specific state information for a product
 */
export type ProductUserStateData = {
    watchlist: WatchlistUserStateData;
};

/**
 * Watchlist-specific user state for a product
 */
export type WatchlistUserStateData = {
    /**
     * Whether the product is on the user's watchlist
     */
    watching: boolean;
    /**
     * Whether notifications are enabled for this watchlist product
     */
    notifications: boolean;
};

/**
 * Text content with language information
 */
export type LocalizedTextData = {
    /**
     * The text content
     */
    text: string;
    language: LanguageData;
};

/**
 * Price information with currency
 */
export type PriceData = {
    currency: CurrencyData;
    /**
     * Price amount in minor currency units (e.g., cents for EUR/USD)
     */
    amount: number;
};

/**
 * Minimal information about an product when it was created
 */
export type ProductCreatedEventPayloadData = {
    state: ProductStateData;
    price?: PriceData;
    priceEstimateMin?: PriceData;
    priceEstimateMax?: PriceData;
};

/**
 * Payload for state change events, containing both old and new state
 */
export type ProductEventStateChangedPayloadData = {
    oldState: ProductStateData;
    newState: ProductStateData;
};

/**
 * Payload for price discovered events when a product's price is first detected
 */
export type ProductEventPriceDiscoveredPayloadData = {
    newPrice: PriceData;
};

/**
 * Payload for price change events (dropped or increased), containing both old and new price
 */
export type ProductEventPriceChangedPayloadData = {
    oldPrice: PriceData;
    newPrice: PriceData;
};

/**
 * Payload for price removed events when a product's price is removed
 */
export type ProductEventPriceRemovedPayloadData = {
    oldPrice: PriceData;
};

/**
 * Historical event for a product
 */
export type GetProductEventData = {
    eventType: ProductEventTypeData;
    /**
     * Unique internal identifier for the product
     */
    productId: string;
    /**
     * Unique identifier for this event
     */
    eventId: string;
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Shop's unique identifier for the product. Can be any arbitrary string.
     */
    shopsProductId: string;
    payload: ProductEventPayloadData;
    /**
     * When the event occurred (RFC3339 format)
     */
    timestamp: string;
};

/**
 * Supported languages (ISO 639-1 codes):
 * - de: German (includes de-DE, de-AT, de-CH, de-LU, de-LI)
 * - en: English (includes en-US, en-GB, en-AU, en-CA, en-NZ, en-IE)
 * - fr: French (includes fr-FR, fr-CA, fr-BE, fr-CH, fr-LU)
 * - es: Spanish (includes es-ES, es-MX, es-AR, es-CO, es-CL, es-PE, es-VE)
 *
 */
export type LanguageData = 'de' | 'en' | 'fr' | 'es';

/**
 * Supported currencies (ISO 4217 codes):
 * - EUR: Euro
 * - GBP: British Pound
 * - USD: US Dollar
 * - AUD: Australian Dollar
 * - CAD: Canadian Dollar
 * - NZD: New Zealand Dollar
 *
 */
export type CurrencyData = 'EUR' | 'GBP' | 'USD' | 'AUD' | 'CAD' | 'NZD';

/**
 * Current state of the product:
 * - LISTED: Product has been listed
 * - AVAILABLE: Product is available for purchase
 * - RESERVED: Product is reserved by a buyer
 * - SOLD: Product has been sold
 * - REMOVED: Product has been removed and can no longer be tracked
 * - UNKNOWN: Product has an unknown state
 *
 */
export type ProductStateData = 'LISTED' | 'AVAILABLE' | 'RESERVED' | 'SOLD' | 'REMOVED' | 'UNKNOWN';

/**
 * Authenticity classification of the antique product:
 * - ORIGINAL: Verified original antique from the stated period
 * - LATER_COPY: Antique copy made at a later time but still historical
 * - REPRODUCTION: Modern reproduction or replica
 * - QUESTIONABLE: Authenticity is disputed or uncertain
 * - UNKNOWN: Authenticity has not been determined
 *
 */
export type AuthenticityData = 'ORIGINAL' | 'LATER_COPY' | 'REPRODUCTION' | 'QUESTIONABLE' | 'UNKNOWN';

/**
 * Physical condition assessment of the antique product:
 * - EXCELLENT: Near-perfect condition with minimal wear
 * - GREAT: Very good condition with minor signs of age
 * - GOOD: Good condition with moderate wear consistent with age
 * - FAIR: Fair condition with significant wear but structurally sound
 * - POOR: Poor condition with major damage or deterioration
 * - UNKNOWN: Condition has not been assessed
 *
 */
export type ConditionData = 'EXCELLENT' | 'GREAT' | 'GOOD' | 'FAIR' | 'POOR' | 'UNKNOWN';

/**
 * Documentation trail and ownership history of the antique product:
 * - COMPLETE: Full documented history from origin to present
 * - PARTIAL: Some documentation exists but history has gaps
 * - CLAIMED: Provenance is claimed by seller but lacks documentation
 * - NONE: No provenance documentation available
 * - UNKNOWN: Provenance status has not been determined
 *
 */
export type ProvenanceData = 'COMPLETE' | 'PARTIAL' | 'CLAIMED' | 'NONE' | 'UNKNOWN';

/**
 * Level of restoration work performed on the antique product:
 * - NONE: No restoration, original condition preserved
 * - MINOR: Minor restoration or conservation work (cleaning, small repairs)
 * - MAJOR: Significant restoration or reconstruction work
 * - UNKNOWN: Restoration history has not been determined
 *
 */
export type RestorationData = 'NONE' | 'MINOR' | 'MAJOR' | 'UNKNOWN';

/**
 * Classification of prohibited or sensitive content that may be present in product images:
 * - UNKNOWN: Content classification has not been determined
 * - NONE: No prohibited content detected in the image
 * - NAZI_GERMANY: Image contains Nazi Germany symbols, insignia, or related content
 *
 */
export type ProhibitedContentData = 'UNKNOWN' | 'NONE' | 'NAZI_GERMANY';

/**
 * Type of vendor or shop:
 * - AUCTION_HOUSE: Auction house selling items through auctions
 * - AUCTION_PLATFORM: Auction platform hosting auctions for auction-houses
 * - COMMERCIAL_DEALER: Commercial dealer or shop selling items directly
 * - MARKETPLACE: Marketplace platform connecting buyers and sellers
 *
 */
export type ShopTypeData = 'AUCTION_HOUSE' | 'AUCTION_PLATFORM' | 'COMMERCIAL_DEALER' | 'MARKETPLACE';

/**
 * Product image with prohibited content classification
 */
export type ProductImageData = {
    /**
     * URL to the product image
     */
    url: string;
    prohibitedContent: ProhibitedContentData;
};

/**
 * Fields available for sorting:
 * - score: Sort by relevance score (default, only available when searching with text query)
 * - price: Sort by product price
 * - originYear: Sort by product origin year
 * - updated: Sort by last updated timestamp
 * - created: Sort by creation timestamp
 *
 */
export type SortProductFieldData = 'score' | 'price' | 'originYear' | 'updated' | 'created';

/**
 * Types of events that can occur for a product
 */
export type ProductEventTypeData = 'CREATED' | 'STATE_LISTED' | 'STATE_AVAILABLE' | 'STATE_RESERVED' | 'STATE_SOLD' | 'STATE_REMOVED' | 'STATE_UNKNOWN' | 'PRICE_DISCOVERED' | 'PRICE_DROPPED' | 'PRICE_INCREASED' | 'PRICE_REMOVED';

/**
 * Event-specific payload data. The structure varies depending on the event type:
 * - CREATED: ProductCreatedEventPayloadData (initial product state and optional price)
 * - STATE_LISTED, STATE_AVAILABLE, STATE_RESERVED, STATE_SOLD, STATE_REMOVED, STATE_UNKNOWN: ProductEventStateChangedPayloadData (old and new state)
 * - PRICE_DISCOVERED: ProductEventPriceDiscoveredPayloadData (new price only, when price is first detected)
 * - PRICE_DROPPED, PRICE_INCREASED: ProductEventPriceChangedPayloadData (old and new price)
 * - PRICE_REMOVED: ProductEventPriceRemovedPayloadData (old price only, when price is removed)
 *
 */
export type ProductEventPayloadData = ProductCreatedEventPayloadData | ProductEventStateChangedPayloadData | ProductEventPriceDiscoveredPayloadData | ProductEventPriceChangedPayloadData | ProductEventPriceRemovedPayloadData;

/**
 * Standard error response format (RFC 9457)
 */
export type ApiError = {
    /**
     * HTTP status code
     */
    status: number;
    /**
     * HTTP status code in human-readable form
     */
    title: string;
    /**
     * Error code identifier
     */
    error: string;
    source?: ApiErrorSource;
    /**
     * Human-readable error message
     */
    detail?: string;
};

/**
 * Information about the source of the error
 */
export type ApiErrorSource = {
    /**
     * Name of the field that caused the error
     */
    field: string;
    /**
     * Type of parameter that caused the error
     */
    sourceType: 'query' | 'path' | 'header' | 'body';
};

/**
 * Product search configuration with query parameters and filtering options
 */
export type ProductSearchData = {
    language: LanguageData;
    currency: CurrencyData;
    /**
     * Text query for searching products (minimum 3 characters)
     */
    productQuery: string;
    /**
     * Optional filter by exact shop names (keyword matching).
     * Filters products to only those from shops with names exactly matching one of the provided values.
     * This is an exact match filter, not a fuzzy text search.
     *
     */
    shopName?: Array<string>;
    /**
     * Optional filter to exclude products from specific shop names (keyword matching).
     * Products from shops with names exactly matching one of the provided values will be excluded from results.
     * This is an exact match filter, not a fuzzy text search.
     * Empty array means no shops are excluded.
     *
     */
    excludeShopName?: Array<string>;
    /**
     * Optional filter by shop types
     */
    shopType?: Array<ShopTypeData> | null;
    /**
     * Optional price range filter in minor currency units
     */
    price?: RangeQueryUInt64 | null;
    /**
     * Optional filter by product states
     */
    state?: Array<ProductStateData> | null;
    /**
     * Optional filter by product origin year range
     */
    originYear?: RangeQueryInt32 | null;
    /**
     * Optional filter by authenticity classifications
     */
    authenticity?: Array<AuthenticityData> | null;
    /**
     * Optional filter by product condition assessments
     */
    condition?: Array<ConditionData> | null;
    /**
     * Optional filter by provenance documentation levels
     */
    provenance?: Array<ProvenanceData> | null;
    /**
     * Optional filter by restoration work levels
     */
    restoration?: Array<RestorationData> | null;
    /**
     * Optional filter by product creation date range
     */
    created?: RangeQueryDateTime | null;
    /**
     * Optional filter by product last updated date range
     */
    updated?: RangeQueryDateTime | null;
    /**
     * Optional filter by auction start datetime range.
     * Filters products by when their auction windows begin.
     * Only matches products that have auction start times set.
     *
     */
    auctionStart?: RangeQueryDateTime | null;
    /**
     * Optional filter by auction end datetime range.
     * Filters products by when their auction windows end.
     * Only matches products that have auction end times set.
     *
     */
    auctionEnd?: RangeQueryDateTime | null;
};

/**
 * Request body for creating a new search filter
 */
export type PostUserSearchFilterData = {
    /**
     * User-defined name for the search filter (max 255 characters, will be truncated if longer)
     */
    name: string;
    productSearch: ProductSearchData;
};

/**
 * Partial search filter update data.
 * All fields are optional and only provided fields will be updated.
 * Can update the search filter name and/or the search filter criteria.
 *
 */
export type PatchUserSearchFilterData = {
    /**
     * User-defined name for the search filter (max 255 characters, will be truncated if longer)
     */
    name?: string | null;
    /**
     * Partial search filter criteria to update
     */
    productSearch?: PatchProductSearchData | null;
};

/**
 * Partial search filter criteria update.
 * All fields are optional and only provided fields will be updated.
 * Follows the same structure as ProductSearchData but with optional fields.
 *
 */
export type PatchProductSearchData = {
    /**
     * Language for search and localized content
     */
    language?: LanguageData | null;
    /**
     * Currency for price display
     */
    currency?: CurrencyData | null;
    /**
     * Text query for searching products (minimum 3 characters when provided)
     */
    productQuery?: string | null;
    /**
     * Optional filter by exact shop names (keyword matching).
     * Filters products to only those from shops with names exactly matching one of the provided values.
     * This is an exact match filter, not a fuzzy text search.
     *
     */
    shopName?: Array<string> | null;
    /**
     * Optional filter to exclude products from specific shop names (keyword matching).
     * Products from shops with names exactly matching one of the provided values will be excluded from results.
     * This is an exact match filter, not a fuzzy text search.
     *
     */
    excludeShopName?: Array<string> | null;
    /**
     * Optional filter by shop types
     */
    shopType?: Array<ShopTypeData> | null;
    /**
     * Optional price range filter in minor currency units
     */
    price?: RangeQueryUInt64 | null;
    /**
     * Optional filter by product states
     */
    state?: Array<ProductStateData> | null;
    /**
     * Optional filter by product origin year range
     */
    originYear?: RangeQueryInt32 | null;
    /**
     * Optional filter by authenticity classifications
     */
    authenticity?: Array<AuthenticityData> | null;
    /**
     * Optional filter by product condition assessments
     */
    condition?: Array<ConditionData> | null;
    /**
     * Optional filter by provenance documentation levels
     */
    provenance?: Array<ProvenanceData> | null;
    /**
     * Optional filter by restoration work levels
     */
    restoration?: Array<RestorationData> | null;
    /**
     * Optional filter by product creation date range
     */
    created?: RangeQueryDateTime | null;
    /**
     * Optional filter by product last updated date range
     */
    updated?: RangeQueryDateTime | null;
    /**
     * Optional filter by auction start datetime range.
     * Filters products by when their auction windows begin.
     * Only matches products that have auction start times set.
     *
     */
    auctionStart?: RangeQueryDateTime | null;
    /**
     * Optional filter by auction end datetime range.
     * Filters products by when their auction windows end.
     * Only matches products that have auction end times set.
     *
     */
    auctionEnd?: RangeQueryDateTime | null;
};

/**
 * Complete user search filter with metadata
 */
export type UserSearchFilterData = {
    /**
     * Unique identifier of the user who owns this search filter
     */
    userId: string;
    /**
     * Unique identifier for this search filter
     */
    userSearchFilterId: string;
    /**
     * User-defined name for the search filter
     */
    name: string;
    productSearch: ProductSearchData;
    /**
     * When the search filter was created (RFC3339 format)
     */
    created: string;
    /**
     * When the search filter was last updated (RFC3339 format)
     */
    updated: string;
};

/**
 * Range query for numeric values (prices in minor currency units)
 */
export type RangeQueryUInt64 = {
    /**
     * Minimum value (inclusive)
     */
    min?: number;
    /**
     * Maximum value (inclusive)
     */
    max?: number;
};

/**
 * Range query for date and time values
 */
export type RangeQueryDateTime = {
    /**
     * Minimum date and time (inclusive, RFC3339 format)
     */
    min?: string;
    /**
     * Maximum date and time (inclusive, RFC3339 format)
     */
    max?: string;
};

/**
 * Range query for integer values (e.g., years)
 */
export type RangeQueryInt32 = {
    /**
     * Minimum value (inclusive)
     */
    min?: number;
    /**
     * Maximum value (inclusive)
     */
    max?: number;
};

/**
 * Fields available for sorting search filters:
 * - created: Sort by creation timestamp
 *
 */
export type SortUserSearchFilterFieldData = 'created';

/**
 * Paginated collection of user search filters with flattened pagination
 */
export type UserSearchFilterCollectionData = {
    /**
     * Array of search filters in the current page
     */
    items: Array<UserSearchFilterData>;
    /**
     * Number of products skipped (offset)
     */
    from: number;
    /**
     * Number of products in the current page
     */
    size: number;
    /**
     * Total number of products matching the query
     */
    total?: number | null;
};

/**
 * Collection of products to create or update
 */
export type PutProductsCollectionData = {
    /**
     * Array of products to process
     */
    items: Array<PutProductData>;
};

/**
 * Data required to create or update a product.
 * Shop information (shopId and shopName) is automatically enriched based on the product's URL.
 *
 */
export type PutProductData = {
    /**
     * Shop's unique identifier for the product. Can be any arbitrary string.
     */
    shopsProductId: string;
    title: LocalizedTextData;
    /**
     * Optional product description
     */
    description?: LocalizedTextData | null;
    /**
     * Optional product price
     */
    price?: PriceData | null;
    /**
     * Optional minimum estimated price for the product
     */
    priceEstimateMin?: PriceData | null;
    /**
     * Optional maximum estimated price for the product
     */
    priceEstimateMax?: PriceData | null;
    state: ProductStateData;
    /**
     * URL to the product on the shop's website.
     * The shop will be automatically identified and enriched based on the domain extracted from this URL.
     *
     */
    url: string;
    /**
     * Array of image URLs for the product
     */
    images?: Array<string>;
    /**
     * Start datetime of the auction window for this product (RFC3339 format).
     * Only applicable for products from auction houses with scheduled auction times.
     * Used to indicate when bidding begins or when the item will be auctioned.
     *
     */
    auctionStart?: string | null;
    /**
     * End datetime of the auction window for this product (RFC3339 format).
     * Only applicable for products from auction houses with scheduled auction times.
     * Used to indicate when bidding ends or when the auction session concludes.
     *
     */
    auctionEnd?: string | null;
};

/**
 * Response from bulk product creation/update operation with enrichment
 */
export type PutProductsResponse = {
    /**
     * Product URLs that could not be processed due to temporary issues.
     * These products may succeed if retried.
     *
     */
    unprocessed?: Array<string>;
    /**
     * Map of product URLs to error codes for products that failed processing.
     * The key is the product URL, and the value is the error code explaining why it failed.
     *
     */
    failed?: {
        [key: string]: PutProductError;
    };
    /**
     * Number of products that were skipped during processing because they had no changes
     */
    skipped: number;
};

/**
 * Complete shop information including metadata
 */
export type GetShopData = {
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Human-readable slug identifier of the shop (kebab-case, derived from shop name).
     * Example: "tech-store-premium" or "christies"
     *
     */
    shopSlugId: string;
    /**
     * Display name of the shop
     */
    name: string;
    shopType: ShopTypeData;
    /**
     * All known domains associated with the shop.
     * Domains are normalized (lowercase, no scheme, no www prefix, no path/query/fragment).
     *
     */
    domains: Array<string>;
    /**
     * Optional URL to the shop's logo or image
     */
    image?: string | null;
    /**
     * When the shop was first created (RFC3339 format)
     */
    created: string;
    /**
     * When the shop was last updated (RFC3339 format)
     */
    updated: string;
};

/**
 * Data required to create a new shop
 */
export type PostShopData = {
    /**
     * Display name of the shop
     */
    name: string;
    shopType: ShopTypeData;
    /**
     * All domains associated with the shop.
     * Can be provided as full URLs (will be normalized) or as domain strings.
     * Domains are normalized to lowercase without scheme, www prefix, or path/query/fragment.
     * At least one domain is required, maximum 100 domains allowed.
     *
     */
    domains: Array<string>;
    /**
     * Optional URL to the shop's logo or image
     */
    image?: string | null;
};

/**
 * Partial update data for a shop.
 * All fields are optional - only provided fields will be updated.
 * If the request body is empty or all fields are null, the shop is returned unchanged.
 *
 * **Note**: The shop name cannot be updated after creation as it determines the shop slug identifier.
 *
 */
export type PatchShopData = {
    /**
     * New shop type classification
     */
    shopType?: ShopTypeData | null;
    /**
     * Complete new set of domains for the shop.
     * Can be provided as full URLs (will be normalized) or as domain strings.
     * When updating domains, the complete new set must be provided (not a diff).
     * Domains are normalized to lowercase without scheme, www prefix, or path/query/fragment.
     * Minimum 1 domain, maximum 100 domains.
     *
     */
    domains?: Array<string> | null;
    /**
     * New URL to the shop's logo or image
     */
    image?: string | null;
};

/**
 * Search filter configuration for shops with query parameters and filtering options
 */
export type ShopSearchData = {
    /**
     * Optional text query for searching shops by name
     */
    shopNameQuery?: string;
    /**
     * Optional filter by shop types
     */
    shopType?: Array<ShopTypeData> | null;
    /**
     * Optional filter by shop creation date range
     */
    created?: RangeQueryDateTime | null;
    /**
     * Optional filter by shop last updated date range
     */
    updated?: RangeQueryDateTime | null;
};

/**
 * Fields available for sorting shops:
 * - score: Sort by relevance score (default, only available when searching with text query)
 * - name: Sort by shop name
 * - updated: Sort by last updated timestamp
 * - created: Sort by creation timestamp
 *
 */
export type SortShopFieldData = 'score' | 'name' | 'updated' | 'created';

/**
 * Cursor-paginated collection of shops using keyset pagination
 */
export type ShopSearchResultData = {
    /**
     * Array of shops in the current page
     */
    items: Array<GetShopData>;
    /**
     * Number of products in the current page
     */
    size: number;
    /**
     * Cursor for the next page (keyset pagination).
     * Contains the sort field value and shop ID as tie-breaker: `[sortValue, shopId]`.
     * Present when there are more results available.
     * This is a heterogeneous JSON array.
     *
     */
    searchAfter?: Array<unknown> | null;
    /**
     * Total number of products matching the query
     */
    total?: number | null;
};

/**
 * Identifier for a product using shop ID and shop's product ID
 */
export type ProductKeyData = {
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Shop's unique identifier for the product. Can be any arbitrary string.
     */
    shopsProductId: string;
};

/**
 * Watchlist product containing the product data and when it was added to the watchlist
 */
export type WatchlistProductData = {
    product: GetProductData;
    /**
     * Whether notifications are enabled for this watchlist product
     */
    notifications: boolean;
    /**
     * When the product was added to the watchlist (RFC3339 format)
     */
    created: string;
    /**
     * When the watchlist product was last updated (RFC3339 format)
     */
    updated: string;
};

/**
 * Paginated collection of watchlist products using cursor-based pagination
 */
export type WatchlistCollectionData = {
    /**
     * Array of watchlist products in the current page
     */
    items: Array<WatchlistProductData>;
    /**
     * Number of products in the current page
     */
    size: number;
    /**
     * Cursor for the next page (RFC3339 timestamp). Present when there are more results.
     */
    searchAfter?: string | null;
    /**
     * Total number of products (optional, may not be available for cursor-based pagination)
     */
    total?: number | null;
};

/**
 * Patch object for updating watchlist product settings
 */
export type WatchlistProductPatch = {
    /**
     * Whether to enable or disable notifications for this watchlist product
     */
    notifications?: boolean;
};

/**
 * Response after patching a watchlist product, containing core product identifiers and notification settings
 */
export type WatchlistProductPatchResponse = {
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Shop's unique identifier for the product
     */
    shopsProductId: string;
    /**
     * Internal product identifier
     */
    productId: string;
    /**
     * Current notification setting for this watchlist product
     */
    notifications: boolean;
    /**
     * When the product was added to the watchlist (RFC3339 format)
     */
    created: string;
    /**
     * When the watchlist product was last updated (RFC3339 format)
     */
    updated: string;
};

/**
 * Fields available for sorting watchlist products:
 * - created: Sort by when product was added to watchlist
 *
 */
export type SortWatchlistProductFieldData = 'created';

/**
 * Error codes for products that failed during processing:
 * - SHOP_NOT_FOUND: The shop associated with the product's domain is not registered in the system
 * - MONETARY_AMOUNT_OVERFLOW: The price amount exceeds the maximum supported value during currency conversion
 * - PRODUCT_ENRICHMENT_FAILED: Failed to enrich the product with additional shop and price information
 * - NO_DOMAIN: The product URL does not contain a valid domain that can be extracted
 *
 */
export type PutProductError = 'SHOP_NOT_FOUND' | 'MONETARY_AMOUNT_OVERFLOW' | 'PRODUCT_ENRICHMENT_FAILED' | 'NO_DOMAIN';

/**
 * Complete user account information
 */
export type GetUserAccountData = {
    /**
     * Unique identifier for the user
     */
    userId: string;
    /**
     * User's email address
     */
    email: string;
    /**
     * User's first name (optional, max 64 characters)
     */
    firstName?: string | null;
    /**
     * User's last name (optional, max 64 characters)
     */
    lastName?: string | null;
    /**
     * User's preferred language (optional)
     */
    language?: LanguageData | null;
    /**
     * User's preferred currency (optional)
     */
    currency?: CurrencyData | null;
    /**
     * When the user account was created (RFC3339 format)
     */
    created: string;
    /**
     * When the user account was last updated (RFC3339 format)
     */
    updated: string;
};

/**
 * Partial user account update data.
 * All fields are optional - only provided fields will be updated.
 *
 */
export type PatchUserAccountData = {
    /**
     * New first name (max 64 characters)
     */
    firstName?: string | null;
    /**
     * New last name (max 64 characters)
     */
    lastName?: string | null;
    /**
     * New preferred language
     */
    language?: LanguageData | null;
    /**
     * New preferred currency
     */
    currency?: CurrencyData | null;
};

export type GetProductData2 = {
    body?: never;
    headers?: {
        /**
         * Preferred language for localized content.
         * Supports quality values and multiple languages.
         * Supported languages: de, en, fr, es (with regional variants).
         *
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * Unique identifier of the shop
         */
        shopId: string;
        /**
         * Shop's unique identifier for the product. Can be any arbitrary string.
         */
        shopsProductId: string;
    };
    query?: {
        /**
         * Currency for price display
         */
        currency?: CurrencyData;
    };
    url: '/api/v1/shops/{shopId}/products/{shopsProductId}';
};

export type GetProductErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Product not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetProductError = GetProductErrors[keyof GetProductErrors];

export type GetProductResponses = {
    /**
     * Product found and returned successfully
     */
    200: PersonalizedGetProductData;
};

export type GetProductResponse = GetProductResponses[keyof GetProductResponses];

export type GetProductBySlugData = {
    body?: never;
    headers?: {
        /**
         * Preferred language for localized content.
         * Supports quality values and multiple languages.
         * Supported languages: de, en, fr, es (with regional variants).
         *
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * Human-readable slug identifier of the shop (kebab-case, derived from shop name)
         */
        shopSlugId: string;
        /**
         * Human-readable slug identifier of the product (kebab-case with 6-character hex suffix).
         * Format: {product-title}-{6-char-hex} where the title is derived from the product name.
         *
         */
        productSlugId: string;
    };
    query?: {
        /**
         * Currency for price display
         */
        currency?: CurrencyData;
    };
    url: '/api/v1/by-slug/shops/{shopSlugId}/products/{productSlugId}';
};

export type GetProductBySlugErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Product not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetProductBySlugError = GetProductBySlugErrors[keyof GetProductBySlugErrors];

export type GetProductBySlugResponses = {
    /**
     * Product found and returned successfully
     */
    200: PersonalizedGetProductData;
};

export type GetProductBySlugResponse = GetProductBySlugResponses[keyof GetProductBySlugResponses];

export type GetProductHistoryData = {
    body?: never;
    headers?: {
        /**
         * Preferred language for localized content.
         * Supports quality values and multiple languages.
         * Supported languages: de, en, fr, es (with regional variants).
         *
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * Unique identifier of the shop
         */
        shopId: string;
        /**
         * Shop's unique identifier for the product. Can be any arbitrary string.
         */
        shopsProductId: string;
    };
    query?: {
        /**
         * Currency for price display in event payloads
         */
        currency?: CurrencyData;
    };
    url: '/api/v1/shops/{shopId}/products/{shopsProductId}/history';
};

export type GetProductHistoryErrors = {
    /**
     * Bad request - Invalid parameters
     */
    400: ApiError;
    /**
     * Product not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetProductHistoryError = GetProductHistoryErrors[keyof GetProductHistoryErrors];

export type GetProductHistoryResponses = {
    /**
     * Product history retrieved successfully
     */
    200: Array<GetProductEventData>;
};

export type GetProductHistoryResponse = GetProductHistoryResponses[keyof GetProductHistoryResponses];

export type GetSimilarProductsData = {
    body?: never;
    headers?: {
        /**
         * Preferred language for localized content.
         * Supports quality values and multiple languages.
         * Supported languages: de, en, fr, es (with regional variants).
         *
         */
        'Accept-Language'?: string;
    };
    path: {
        /**
         * Unique identifier of the shop
         */
        shopId: string;
        /**
         * Shop's unique identifier for the product
         */
        shopsProductId: string;
    };
    query?: {
        /**
         * Currency for price display
         */
        currency?: CurrencyData;
    };
    url: '/api/v1/shops/{shopId}/products/{shopsProductId}/similar';
};

export type GetSimilarProductsErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Product not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetSimilarProductsError = GetSimilarProductsErrors[keyof GetSimilarProductsErrors];

export type GetSimilarProductsResponses = {
    /**
     * Array of similar products, each with optional user state
     */
    200: Array<PersonalizedGetProductSummaryData>;
    /**
     * Accepted - Product embedding not yet computed.
     * The text embedding for this product has not been generated yet (typically for products less than 24 hours old).
     * Embeddings are computed during nightly batch processing.
     * Poll the endpoint again later using the Location header.
     *
     */
    202: unknown;
};

export type GetSimilarProductsResponse = GetSimilarProductsResponses[keyof GetSimilarProductsResponses];

export type PutProductsData = {
    /**
     * Collection of products to create or update
     */
    body: PutProductsCollectionData;
    path?: never;
    query?: never;
    url: '/api/v1/products';
};

export type PutProductsErrors = {
    /**
     * Bad request - invalid request body
     */
    400: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type PutProductsError = PutProductsErrors[keyof PutProductsErrors];

export type PutProductsResponses = {
    /**
     * Products processed successfully
     */
    200: PutProductsResponse;
};

export type PutProductsResponse2 = PutProductsResponses[keyof PutProductsResponses];

export type ComplexSearchProductsData = {
    /**
     * Search filter configuration with all filtering criteria.
     * Unlike the simple text search, this allows filtering by multiple fields,
     * price ranges, product states, and date ranges.
     *
     */
    body: ProductSearchData;
    path?: never;
    query?: {
        /**
         * Field to sort results by
         */
        sort?: SortProductFieldData;
        /**
         * Sort order (only valid when sort is specified)
         */
        order?: 'asc' | 'desc';
        /**
         * Cursor value for pagination (search-after pattern).
         * This is a JSON value returned as `searchAfter` in the previous response.
         * Use this to fetch the next page of results.
         * In general you do not have to worry about determining this key. It's given with the `searchAfter` field in the preceding response if more entries are present.
         * This can be ANY heterogeneous array.
         *
         */
        searchAfter?: Array<unknown>;
        /**
         * Number of products to return per page
         */
        size?: number;
    };
    url: '/api/v1/products/search';
};

export type ComplexSearchProductsErrors = {
    /**
     * Bad request - invalid parameters or body
     */
    400: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type ComplexSearchProductsError = ComplexSearchProductsErrors[keyof ComplexSearchProductsErrors];

export type ComplexSearchProductsResponses = {
    /**
     * Complex search results returned successfully
     */
    200: PersonalizedProductSearchResultData;
};

export type ComplexSearchProductsResponse = ComplexSearchProductsResponses[keyof ComplexSearchProductsResponses];

export type GetUserSearchFiltersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Field to sort results by
         */
        sort?: SortUserSearchFilterFieldData;
        /**
         * Sort order (only valid when sort is specified)
         */
        order?: 'asc' | 'desc';
    };
    url: '/api/v1/me/search-filters';
};

export type GetUserSearchFiltersErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetUserSearchFiltersError = GetUserSearchFiltersErrors[keyof GetUserSearchFiltersErrors];

export type GetUserSearchFiltersResponses = {
    /**
     * Search filters retrieved successfully
     */
    200: UserSearchFilterCollectionData;
};

export type GetUserSearchFiltersResponse = GetUserSearchFiltersResponses[keyof GetUserSearchFiltersResponses];

export type CreateUserSearchFilterData = {
    /**
     * Search filter configuration with name and filter criteria
     */
    body: PostUserSearchFilterData;
    path?: never;
    query?: never;
    url: '/api/v1/me/search-filters';
};

export type CreateUserSearchFilterErrors = {
    /**
     * Bad request - invalid request body
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type CreateUserSearchFilterError = CreateUserSearchFilterErrors[keyof CreateUserSearchFilterErrors];

export type CreateUserSearchFilterResponses = {
    /**
     * Search filter created successfully
     */
    201: UserSearchFilterData;
};

export type CreateUserSearchFilterResponse = CreateUserSearchFilterResponses[keyof CreateUserSearchFilterResponses];

export type DeleteUserSearchFilterData = {
    body?: never;
    path: {
        /**
         * Unique identifier of the search filter to delete
         */
        userSearchFilterId: string;
    };
    query?: never;
    url: '/api/v1/me/search-filters/{userSearchFilterId}';
};

export type DeleteUserSearchFilterErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Search filter not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type DeleteUserSearchFilterError = DeleteUserSearchFilterErrors[keyof DeleteUserSearchFilterErrors];

export type DeleteUserSearchFilterResponses = {
    /**
     * Search filter deleted successfully
     */
    204: void;
};

export type DeleteUserSearchFilterResponse = DeleteUserSearchFilterResponses[keyof DeleteUserSearchFilterResponses];

export type GetUserSearchFilterData = {
    body?: never;
    path: {
        /**
         * Unique identifier of the search filter
         */
        userSearchFilterId: string;
    };
    query?: never;
    url: '/api/v1/me/search-filters/{userSearchFilterId}';
};

export type GetUserSearchFilterErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Search filter not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetUserSearchFilterError = GetUserSearchFilterErrors[keyof GetUserSearchFilterErrors];

export type GetUserSearchFilterResponses = {
    /**
     * Search filter found and returned successfully
     */
    200: UserSearchFilterData;
};

export type GetUserSearchFilterResponse = GetUserSearchFilterResponses[keyof GetUserSearchFilterResponses];

export type UpdateUserSearchFilterData = {
    /**
     * Partial search filter update data.
     * Only provided fields will be updated. If body is empty, returns existing filter.
     *
     */
    body?: PatchUserSearchFilterData;
    path: {
        /**
         * Unique identifier of the search filter to update
         */
        userSearchFilterId: string;
    };
    query?: never;
    url: '/api/v1/me/search-filters/{userSearchFilterId}';
};

export type UpdateUserSearchFilterErrors = {
    /**
     * Bad request - invalid parameters or body
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Search filter not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type UpdateUserSearchFilterError = UpdateUserSearchFilterErrors[keyof UpdateUserSearchFilterErrors];

export type UpdateUserSearchFilterResponses = {
    /**
     * Search filter updated successfully
     */
    200: UserSearchFilterData;
};

export type UpdateUserSearchFilterResponse = UpdateUserSearchFilterResponses[keyof UpdateUserSearchFilterResponses];

export type GetWatchlistProductsData = {
    body?: never;
    headers?: {
        /**
         * Preferred language for localized content.
         * Supports quality values and multiple languages.
         * Supported languages: de, en, fr, es (with regional variants).
         *
         */
        'Accept-Language'?: string;
    };
    path?: never;
    query?: {
        /**
         * Currency for price display
         */
        currency?: CurrencyData;
        /**
         * Field to sort results by
         */
        sort?: SortWatchlistProductFieldData;
        /**
         * Sort order (only valid when sort is specified)
         */
        order?: 'asc' | 'desc';
        /**
         * RFC3339 timestamp for cursor-based pagination (search-after).
         * Depending on sort-order, returns watchlist-products created, either after this timestamp for asc (oldest first) or before this timestamp for desc (latest first).
         * In general you do not have to worry about determining this key. It's given with `searchAfter` in the preceding response if more entries are present.
         *
         */
        searchAfter?: string;
        /**
         * Number of products to return per page
         */
        size?: number;
    };
    url: '/api/v1/me/watchlist';
};

export type GetWatchlistProductsErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetWatchlistProductsError = GetWatchlistProductsErrors[keyof GetWatchlistProductsErrors];

export type GetWatchlistProductsResponses = {
    /**
     * Watchlist products retrieved successfully
     */
    200: WatchlistCollectionData;
};

export type GetWatchlistProductsResponse = GetWatchlistProductsResponses[keyof GetWatchlistProductsResponses];

export type AddWatchlistProductData = {
    /**
     * Product identifier to add to watchlist
     */
    body: ProductKeyData;
    path?: never;
    query?: never;
    url: '/api/v1/me/watchlist';
};

export type AddWatchlistProductErrors = {
    /**
     * Bad request - invalid request body
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Unprocessable Entity - watchlist quota exceeded
     */
    422: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type AddWatchlistProductError = AddWatchlistProductErrors[keyof AddWatchlistProductErrors];

export type AddWatchlistProductResponses = {
    /**
     * Product added to watchlist successfully
     */
    201: WatchlistProductPatchResponse;
};

export type AddWatchlistProductResponse = AddWatchlistProductResponses[keyof AddWatchlistProductResponses];

export type GetUserAccountData2 = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v1/me/account';
};

export type GetUserAccountErrors = {
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * User not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetUserAccountError = GetUserAccountErrors[keyof GetUserAccountErrors];

export type GetUserAccountResponses = {
    /**
     * User account data retrieved successfully
     */
    200: GetUserAccountData;
};

export type GetUserAccountResponse = GetUserAccountResponses[keyof GetUserAccountResponses];

export type UpdateUserAccountData = {
    /**
     * Partial user account update data.
     * All fields are optional - only provided fields will be updated.
     *
     */
    body: PatchUserAccountData;
    path?: never;
    query?: never;
    url: '/api/v1/me/account';
};

export type UpdateUserAccountErrors = {
    /**
     * Bad request - invalid request body
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * User not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type UpdateUserAccountError = UpdateUserAccountErrors[keyof UpdateUserAccountErrors];

export type UpdateUserAccountResponses = {
    /**
     * User account updated successfully
     */
    200: GetUserAccountData;
};

export type UpdateUserAccountResponse = UpdateUserAccountResponses[keyof UpdateUserAccountResponses];

export type DeleteWatchlistProductData = {
    body?: never;
    path: {
        /**
         * Unique identifier of the shop
         */
        shopId: string;
        /**
         * Shop's unique identifier for the product
         */
        shopsProductId: string;
    };
    query?: never;
    url: '/api/v1/me/watchlist/{shopId}/{shopsProductId}';
};

export type DeleteWatchlistProductErrors = {
    /**
     * Bad request - invalid parameters
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Watchlist entry not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type DeleteWatchlistProductError = DeleteWatchlistProductErrors[keyof DeleteWatchlistProductErrors];

export type DeleteWatchlistProductResponses = {
    /**
     * Product removed from watchlist successfully
     */
    204: void;
};

export type DeleteWatchlistProductResponse = DeleteWatchlistProductResponses[keyof DeleteWatchlistProductResponses];

export type PatchWatchlistProductData = {
    /**
     * Patch object containing fields to update
     */
    body: WatchlistProductPatch;
    path: {
        /**
         * Unique identifier of the shop
         */
        shopId: string;
        /**
         * Shop's unique identifier for the product
         */
        shopsProductId: string;
    };
    query?: never;
    url: '/api/v1/me/watchlist/{shopId}/{shopsProductId}';
};

export type PatchWatchlistProductErrors = {
    /**
     * Bad request - invalid parameters or body
     */
    400: ApiError;
    /**
     * Unauthorized - invalid or missing JWT token
     */
    401: ApiError;
    /**
     * Watchlist entry not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type PatchWatchlistProductError = PatchWatchlistProductErrors[keyof PatchWatchlistProductErrors];

export type PatchWatchlistProductResponses = {
    /**
     * Watchlist product updated successfully
     */
    200: WatchlistProductPatchResponse;
};

export type PatchWatchlistProductResponse = PatchWatchlistProductResponses[keyof PatchWatchlistProductResponses];

export type CreateShopData = {
    /**
     * Shop data for creating a new shop
     */
    body: PostShopData;
    path?: never;
    query?: never;
    url: '/api/v1/shops';
};

export type CreateShopErrors = {
    /**
     * Bad request - invalid request body
     */
    400: ApiError;
    /**
     * Conflict - shop with this name/slug or domain already exists
     */
    409: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
    /**
     * Service temporarily unavailable
     */
    503: ApiError;
};

export type CreateShopError = CreateShopErrors[keyof CreateShopErrors];

export type CreateShopResponses = {
    /**
     * Shop created successfully
     */
    201: GetShopData;
};

export type CreateShopResponse = CreateShopResponses[keyof CreateShopResponses];

export type GetShopByIdData = {
    body?: never;
    path: {
        /**
         * Unique identifier of the shop (UUID format)
         */
        shopId: string;
    };
    query?: never;
    url: '/api/v1/shops/{shopId}';
};

export type GetShopByIdErrors = {
    /**
     * Bad request - invalid or missing shop ID
     */
    400: ApiError;
    /**
     * Shop not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetShopByIdError = GetShopByIdErrors[keyof GetShopByIdErrors];

export type GetShopByIdResponses = {
    /**
     * Shop found and returned successfully
     */
    200: GetShopData;
};

export type GetShopByIdResponse = GetShopByIdResponses[keyof GetShopByIdResponses];

export type UpdateShopByIdData = {
    /**
     * Partial shop update data.
     * Only provided fields will be updated. All fields are optional.
     * The shop name cannot be updated.
     *
     */
    body: PatchShopData;
    path: {
        /**
         * Unique identifier of the shop to update (UUID format)
         */
        shopId: string;
    };
    query?: never;
    url: '/api/v1/shops/{shopId}';
};

export type UpdateShopByIdErrors = {
    /**
     * Bad request - invalid parameters or body
     */
    400: ApiError;
    /**
     * Shop not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
    /**
     * Service temporarily unavailable
     */
    503: ApiError;
};

export type UpdateShopByIdError = UpdateShopByIdErrors[keyof UpdateShopByIdErrors];

export type UpdateShopByIdResponses = {
    /**
     * Shop updated successfully
     */
    200: GetShopData;
};

export type UpdateShopByIdResponse = UpdateShopByIdResponses[keyof UpdateShopByIdResponses];

export type GetShopByDomainData = {
    body?: never;
    path: {
        /**
         * Domain associated with the shop (e.g., "tech-store.com", "shop.example.com").
         * The domain is normalized (lowercased, www prefix removed).
         *
         */
        shopDomain: string;
    };
    query?: never;
    url: '/api/v1/by-domain/shops/{shopDomain}';
};

export type GetShopByDomainErrors = {
    /**
     * Bad request - invalid or missing domain
     */
    400: ApiError;
    /**
     * Shop not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetShopByDomainError = GetShopByDomainErrors[keyof GetShopByDomainErrors];

export type GetShopByDomainResponses = {
    /**
     * Shop found and returned successfully
     */
    200: GetShopData;
};

export type GetShopByDomainResponse = GetShopByDomainResponses[keyof GetShopByDomainResponses];

export type UpdateShopByDomainData = {
    /**
     * Partial shop update data.
     * Only provided fields will be updated. All fields are optional.
     * The shop name cannot be updated.
     *
     */
    body: PatchShopData;
    path: {
        /**
         * Domain associated with the shop to update (e.g., "tech-store.com", "shop.example.com").
         * The domain is normalized (lowercased, www prefix removed).
         *
         */
        shopDomain: string;
    };
    query?: never;
    url: '/api/v1/by-domain/shops/{shopDomain}';
};

export type UpdateShopByDomainErrors = {
    /**
     * Bad request - invalid parameters or body
     */
    400: ApiError;
    /**
     * Shop not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
    /**
     * Service temporarily unavailable
     */
    503: ApiError;
};

export type UpdateShopByDomainError = UpdateShopByDomainErrors[keyof UpdateShopByDomainErrors];

export type UpdateShopByDomainResponses = {
    /**
     * Shop updated successfully
     */
    200: GetShopData;
};

export type UpdateShopByDomainResponse = UpdateShopByDomainResponses[keyof UpdateShopByDomainResponses];

export type GetShopBySlugData = {
    body?: never;
    path: {
        /**
         * Human-readable slug identifier of the shop (kebab-case, derived from shop name)
         */
        shopSlugId: string;
    };
    query?: never;
    url: '/api/v1/by-slug/shops/{shopSlugId}';
};

export type GetShopBySlugErrors = {
    /**
     * Bad request - invalid or missing shop slug identifier
     */
    400: ApiError;
    /**
     * Shop not found
     */
    404: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type GetShopBySlugError = GetShopBySlugErrors[keyof GetShopBySlugErrors];

export type GetShopBySlugResponses = {
    /**
     * Shop found and returned successfully
     */
    200: GetShopData;
};

export type GetShopBySlugResponse = GetShopBySlugResponses[keyof GetShopBySlugResponses];

export type SearchShopsData = {
    /**
     * Shop search filter configuration with all filtering criteria.
     * Allows filtering by shop name and creation/update date ranges.
     * If you do not want to restrict the search, supply an empty JSON-Object '{}' as body.
     *
     */
    body: ShopSearchData;
    path?: never;
    query?: {
        /**
         * Field to sort results by
         */
        sort?: SortShopFieldData;
        /**
         * Sort order (only valid when sort is specified)
         */
        order?: 'asc' | 'desc';
        /**
         * Cursor value for keyset pagination (search-after pattern).
         * This is a JSON array value returned as `searchAfter` in the previous response.
         * Use this to fetch the next page of results.
         * In general you do not have to worry about determining this key. It's given with the `searchAfter` field in the preceding response if more entries are present.
         * The array contains the sort field value and the shop ID as a tie-breaker: `[sortValue, shopId]`.
         *
         */
        searchAfter?: Array<unknown>;
        /**
         * Number of shops to return per page
         */
        size?: number;
    };
    url: '/api/v1/shops/search';
};

export type SearchShopsErrors = {
    /**
     * Bad request - invalid parameters or body
     */
    400: ApiError;
    /**
     * Internal server error
     */
    500: ApiError;
};

export type SearchShopsError = SearchShopsErrors[keyof SearchShopsErrors];

export type SearchShopsResponses = {
    /**
     * Shop search results returned successfully
     */
    200: ShopSearchResultData;
};

export type SearchShopsResponse = SearchShopsResponses[keyof SearchShopsResponses];
