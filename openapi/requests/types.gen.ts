// This file is auto-generated by @hey-api/openapi-ts

/**
 * Complete item information including metadata and localized content
 */
export type GetItemData = {
    /**
     * Unique internal identifier for the item
     */
    itemId: string;
    /**
     * Unique identifier for the current state/version of the item
     */
    eventId: string;
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Shop's unique identifier for the item
     */
    shopsItemId: string;
    /**
     * Display name of the shop
     */
    shopName: string;
    title: LocalizedTextData;
    /**
     * Optional item description
     */
    description?: (LocalizedTextData) | null;
    /**
     * Optional item price
     */
    price?: (PriceData) | null;
    state: ItemStateData;
    /**
     * URL to the item on the shop's website
     */
    url: string;
    /**
     * Array of image URLs for the item
     */
    images: Array<(string)>;
    /**
     * When the item was first created (RFC3339 format)
     */
    created: string;
    /**
     * When the item was last updated (RFC3339 format)
     */
    updated: string;
    /**
     * Optional array of item history events
     */
    history?: Array<GetItemEventData> | null;
};

/**
 * Paginated collection of items
 */
export type CollectionData = {
    /**
     * Array of items in the current page
     */
    items: Array<GetItemData>;
    pagination: PaginationData;
};

/**
 * Pagination metadata
 */
export type PaginationData = {
    /**
     * Number of items skipped (offset)
     */
    from: number;
    /**
     * Number of items in the current page
     */
    size: number;
    /**
     * Total number of items matching the query
     */
    total: number;
};

/**
 * Text content with language information
 */
export type LocalizedTextData = {
    /**
     * The text content
     */
    text: string;
    language: LanguageData;
};

/**
 * Price information with currency
 */
export type PriceData = {
    currency: CurrencyData;
    /**
     * Price amount in minor currency units (e.g., cents for EUR/USD)
     */
    amount: number;
};

/**
 * Historical event for an item
 */
export type GetItemEventData = {
    eventType: ItemEventTypeData;
    /**
     * Unique internal identifier for the item
     */
    itemId: string;
    /**
     * Unique identifier for this event
     */
    eventId: string;
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Shop's unique identifier for the item
     */
    shopsItemId: string;
    payload: ItemEventPayloadData;
    /**
     * When the event occurred (RFC3339 format)
     */
    timestamp: string;
};

/**
 * Supported languages (ISO 639-1 codes):
 * - de: German (includes de-DE, de-AT, de-CH, de-LU, de-LI)
 * - en: English (includes en-US, en-GB, en-AU, en-CA, en-NZ, en-IE)
 * - fr: French (includes fr-FR, fr-CA, fr-BE, fr-CH, fr-LU)
 * - es: Spanish (includes es-ES, es-MX, es-AR, es-CO, es-CL, es-PE, es-VE)
 *
 */
export type LanguageData = 'de' | 'en' | 'fr' | 'es';

/**
 * Supported currencies (ISO 4217 codes):
 * - EUR: Euro
 * - GBP: British Pound
 * - USD: US Dollar
 * - AUD: Australian Dollar
 * - CAD: Canadian Dollar
 * - NZD: New Zealand Dollar
 *
 */
export type CurrencyData = 'EUR' | 'GBP' | 'USD' | 'AUD' | 'CAD' | 'NZD';

/**
 * Current state of the item:
 * - LISTED: Item has been listed
 * - AVAILABLE: Item is available for purchase
 * - RESERVED: Item is reserved by a buyer
 * - SOLD: Item has been sold
 * - REMOVED: Item has been removed and can no longer be tracked
 *
 */
export type ItemStateData = 'LISTED' | 'AVAILABLE' | 'RESERVED' | 'SOLD' | 'REMOVED';

/**
 * Fields available for sorting:
 * - price: Sort by item price
 * - updated: Sort by last updated timestamp
 * - created: Sort by creation timestamp
 *
 */
export type SortItemFieldData = 'price' | 'updated' | 'created';

/**
 * Types of events that can occur for an item
 */
export type ItemEventTypeData = 'STATE_AVAILABLE' | 'PRICE_DROPPED' | 'STATE_LISTED' | 'STATE_RESERVED' | 'STATE_SOLD' | 'STATE_REMOVED';

/**
 * Event-specific payload data
 */
export type ItemEventPayloadData = ItemStateData | PriceData;

/**
 * Standard error response format
 */
export type ApiError = {
    /**
     * HTTP status code
     */
    status: number;
    /**
     * Error code identifier
     */
    error: string;
    source?: ApiErrorSource;
    /**
     * Human-readable error message
     */
    message?: string;
};

/**
 * Information about the source of the error
 */
export type ApiErrorSource = {
    /**
     * Name of the field that caused the error
     */
    field: string;
    /**
     * Type of parameter that caused the error
     */
    sourceType: 'query' | 'path' | 'header' | 'body';
};

/**
 * Type of parameter that caused the error
 */
export type sourceType = 'query' | 'path' | 'header' | 'body';

/**
 * Search filter configuration with query parameters and filtering options
 */
export type SearchFilterData = {
    language: LanguageData;
    currency: CurrencyData;
    /**
     * Text query for searching items (minimum 3 characters)
     */
    itemQuery: string;
    /**
     * Optional text query for filtering by shop name
     */
    shopNameQuery?: string | null;
    /**
     * Optional price range filter in minor currency units
     */
    price?: (RangeQueryUInt64) | null;
    /**
     * Optional filter by item states
     */
    state?: Array<ItemStateData>;
    /**
     * Optional filter by item creation date range
     */
    created?: (RangeQueryDateTime) | null;
    /**
     * Optional filter by item last updated date range
     */
    updated?: (RangeQueryDateTime) | null;
};

/**
 * Partial search filter update data.
 * All fields are optional and only provided fields will be updated.
 * Follows the same structure as SearchFilterData but with optional fields.
 *
 */
export type SearchFilterDataPatch = {
    /**
     * Language for search and localized content
     */
    language?: (LanguageData) | null;
    /**
     * Currency for price display
     */
    currency?: (CurrencyData) | null;
    /**
     * Text query for searching items (minimum 3 characters when provided)
     */
    itemQuery?: string | null;
    /**
     * Optional text query for filtering by shop name (minimum 3 characters when provided)
     */
    shopNameQuery?: string | null;
    /**
     * Optional price range filter in minor currency units
     */
    price?: (RangeQueryUInt64) | null;
    /**
     * Optional filter by item states
     */
    state?: Array<ItemStateData> | null;
    /**
     * Optional filter by item creation date range
     */
    created?: (RangeQueryDateTime) | null;
    /**
     * Optional filter by item last updated date range
     */
    updated?: (RangeQueryDateTime) | null;
};

/**
 * Complete user search filter with metadata
 */
export type UserSearchFilterData = {
    /**
     * Unique identifier of the user who owns this search filter
     */
    userId: string;
    /**
     * Unique identifier for this search filter
     */
    searchFilterId: string;
    searchFilter: SearchFilterData;
    /**
     * When the search filter was created (RFC3339 format)
     */
    created: string;
    /**
     * When the search filter was last updated (RFC3339 format)
     */
    updated: string;
};

/**
 * Range query for numeric values (prices in minor currency units)
 */
export type RangeQueryUInt64 = {
    /**
     * Minimum value (inclusive)
     */
    min?: number;
    /**
     * Maximum value (inclusive)
     */
    max?: number;
};

/**
 * Range query for date and time values
 */
export type RangeQueryDateTime = {
    /**
     * Minimum date and time (inclusive, RFC3339 format)
     */
    min?: string;
    /**
     * Maximum date and time (inclusive, RFC3339 format)
     */
    max?: string;
};

/**
 * Fields available for sorting search filters:
 * - created: Sort by creation timestamp
 *
 */
export type SortSearchFilterFieldData = 'created';

/**
 * Paginated collection of user search filters
 */
export type CollectionDataUserSearchFilter = {
    /**
     * Array of search filters in the current page
     */
    items: Array<UserSearchFilterData>;
    pagination: PaginationData;
};

export type GetApiV1ItemsByShopIdByShopsItemIdData = {
    /**
     * Preferred language for localized content.
     * Supports quality values and multiple languages.
     * Supported languages: de, en, fr, es (with regional variants).
     *
     */
    acceptLanguage?: string;
    /**
     * Currency for price display
     */
    currency?: CurrencyData;
    /**
     * Whether to include item history in the response
     */
    history?: boolean;
    /**
     * Unique identifier of the shop
     */
    shopId: string;
    /**
     * Shop's unique identifier for the item
     */
    shopsItemId: string;
};

export type GetApiV1ItemsByShopIdByShopsItemIdResponse = GetItemData;

export type GetApiV1ItemsData = {
    /**
     * Currency for price display
     */
    currency?: CurrencyData;
    /**
     * Pagination offset (number of items to skip)
     */
    from?: number;
    /**
     * Language for search and localized content
     */
    language?: LanguageData;
    /**
     * Sort order (only valid when sort is specified)
     */
    order?: 'asc' | 'desc';
    /**
     * Text search query (minimum 3 characters)
     */
    q: string;
    /**
     * Number of items to return per page
     */
    size?: number;
    /**
     * Field to sort results by
     */
    sort?: SortItemFieldData;
};

export type GetApiV1ItemsResponse = CollectionData;

export type PostApiV1ItemsSearchData = {
    /**
     * Pagination offset (number of items to skip)
     */
    from?: number;
    /**
     * Sort order (only valid when sort is specified)
     */
    order?: 'asc' | 'desc';
    /**
     * Search filter configuration with all filtering criteria.
     * Unlike the simple text search, this allows filtering by multiple fields,
     * price ranges, item states, and date ranges.
     *
     */
    requestBody: SearchFilterData;
    /**
     * Number of items to return per page
     */
    size?: number;
    /**
     * Field to sort results by
     */
    sort?: SortItemFieldData;
};

export type PostApiV1ItemsSearchResponse = CollectionData;

export type GetApiV1SearchFiltersData = {
    /**
     * Cognito JWT token for user authentication
     */
    authorization: string;
    /**
     * Sort order (only valid when sort is specified)
     */
    order?: 'asc' | 'desc';
    /**
     * Field to sort results by
     */
    sort?: SortSearchFilterFieldData;
};

export type GetApiV1SearchFiltersResponse = CollectionDataUserSearchFilter;

export type PostApiV1SearchFiltersData = {
    /**
     * Cognito JWT token for user authentication
     */
    authorization: string;
    /**
     * Search filter configuration
     */
    requestBody: SearchFilterData;
};

export type PostApiV1SearchFiltersResponse = UserSearchFilterData;

export type GetApiV1SearchFiltersBySearchFilterIdData = {
    /**
     * Cognito JWT token for user authentication
     */
    authorization: string;
    /**
     * Unique identifier of the search filter
     */
    searchFilterId: string;
};

export type GetApiV1SearchFiltersBySearchFilterIdResponse = UserSearchFilterData;

export type DeleteApiV1SearchFiltersBySearchFilterIdData = {
    /**
     * Cognito JWT token for user authentication
     */
    authorization: string;
    /**
     * Unique identifier of the search filter to delete
     */
    searchFilterId: string;
};

export type DeleteApiV1SearchFiltersBySearchFilterIdResponse = string;

export type PatchApiV1SearchFiltersBySearchFilterIdData = {
    /**
     * Cognito JWT token for user authentication
     */
    authorization: string;
    /**
     * Partial search filter update data.
     * Only provided fields will be updated. If body is empty, returns existing filter.
     *
     */
    requestBody?: SearchFilterDataPatch;
    /**
     * Unique identifier of the search filter to update
     */
    searchFilterId: string;
};

export type PatchApiV1SearchFiltersBySearchFilterIdResponse = UserSearchFilterData;

export type $OpenApiTs = {
    '/api/v1/items/{shopId}/{shopsItemId}': {
        get: {
            req: GetApiV1ItemsByShopIdByShopsItemIdData;
            res: {
                /**
                 * Item found and returned successfully
                 */
                200: GetItemData;
                /**
                 * Bad request - invalid parameters
                 */
                400: ApiError;
                /**
                 * Item not found
                 */
                404: ApiError;
                /**
                 * Internal server error
                 */
                500: ApiError;
            };
        };
    };
    '/api/v1/items': {
        get: {
            req: GetApiV1ItemsData;
            res: {
                /**
                 * Search results returned successfully
                 */
                200: CollectionData;
                /**
                 * Bad request - invalid parameters
                 */
                400: ApiError;
                /**
                 * Internal server error
                 */
                500: ApiError;
            };
        };
    };
    '/api/v1/items/search': {
        post: {
            req: PostApiV1ItemsSearchData;
            res: {
                /**
                 * Complex search results returned successfully
                 */
                200: CollectionData;
                /**
                 * Bad request - invalid parameters or body
                 */
                400: ApiError;
                /**
                 * Internal server error
                 */
                500: ApiError;
            };
        };
    };
    '/api/v1/search-filters': {
        get: {
            req: GetApiV1SearchFiltersData;
            res: {
                /**
                 * Search filters retrieved successfully
                 */
                200: CollectionDataUserSearchFilter;
                /**
                 * Bad request - invalid parameters
                 */
                400: ApiError;
                /**
                 * Unauthorized - invalid or missing JWT token
                 */
                401: ApiError;
                /**
                 * Internal server error
                 */
                500: ApiError;
            };
        };
        post: {
            req: PostApiV1SearchFiltersData;
            res: {
                /**
                 * Search filter created successfully
                 */
                201: UserSearchFilterData;
                /**
                 * Bad request - invalid request body
                 */
                400: ApiError;
                /**
                 * Unauthorized - invalid or missing JWT token
                 */
                401: ApiError;
                /**
                 * Internal server error
                 */
                500: ApiError;
            };
        };
    };
    '/api/v1/search-filters/{searchFilterId}': {
        get: {
            req: GetApiV1SearchFiltersBySearchFilterIdData;
            res: {
                /**
                 * Search filter found and returned successfully
                 */
                200: UserSearchFilterData;
                /**
                 * Bad request - invalid parameters
                 */
                400: ApiError;
                /**
                 * Unauthorized - invalid or missing JWT token
                 */
                401: ApiError;
                /**
                 * Search filter not found
                 */
                404: ApiError;
                /**
                 * Internal server error
                 */
                500: ApiError;
            };
        };
        delete: {
            req: DeleteApiV1SearchFiltersBySearchFilterIdData;
            res: {
                /**
                 * Search filter deleted successfully
                 */
                204: string;
                /**
                 * Bad request - invalid parameters
                 */
                400: ApiError;
                /**
                 * Unauthorized - invalid or missing JWT token
                 */
                401: ApiError;
                /**
                 * Search filter not found
                 */
                404: ApiError;
                /**
                 * Internal server error
                 */
                500: ApiError;
            };
        };
        patch: {
            req: PatchApiV1SearchFiltersBySearchFilterIdData;
            res: {
                /**
                 * Search filter updated successfully
                 */
                200: UserSearchFilterData;
                /**
                 * Bad request - invalid parameters or body
                 */
                400: ApiError;
                /**
                 * Unauthorized - invalid or missing JWT token
                 */
                401: ApiError;
                /**
                 * Search filter not found
                 */
                404: ApiError;
                /**
                 * Internal server error
                 */
                500: ApiError;
            };
        };
    };
};