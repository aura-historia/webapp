// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from './core/CancelablePromise';
import { OpenAPI } from './core/OpenAPI';
import { request as __request } from './core/request';
import type { GetApiV1ItemsByShopIdByShopsItemIdData, GetApiV1ItemsByShopIdByShopsItemIdResponse, GetApiV1ItemsData, GetApiV1ItemsResponse, PostApiV1ItemsSearchData, PostApiV1ItemsSearchResponse, GetApiV1SearchFiltersData, GetApiV1SearchFiltersResponse, PostApiV1SearchFiltersData, PostApiV1SearchFiltersResponse, GetApiV1SearchFiltersBySearchFilterIdData, GetApiV1SearchFiltersBySearchFilterIdResponse, DeleteApiV1SearchFiltersBySearchFilterIdData, DeleteApiV1SearchFiltersBySearchFilterIdResponse, PatchApiV1SearchFiltersBySearchFilterIdData, PatchApiV1SearchFiltersBySearchFilterIdResponse } from './types.gen';

export class ItemsService {
    /**
     * Get a single item
     * Retrieves a single item by its shop ID and shop's item ID.
     * Returns localized content based on Accept-Language header and currency preferences.
     * Optionally includes item history when requested.
     *
     * @param data The data for the request.
     * @param data.shopId Unique identifier of the shop
     * @param data.shopsItemId Shop's unique identifier for the item
     * @param data.currency Currency for price display
     * @param data.history Whether to include item history in the response
     * @param data.acceptLanguage Preferred language for localized content.
     * Supports quality values and multiple languages.
     * Supported languages: de, en, fr, es (with regional variants).
     *
     * @returns GetItemData Item found and returned successfully
     * @throws ApiError
     */
    public static getApiV1ItemsByShopIdByShopsItemId(data: GetApiV1ItemsByShopIdByShopsItemIdData): CancelablePromise<GetApiV1ItemsByShopIdByShopsItemIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/items/{shopId}/{shopsItemId}',
            path: {
                shopId: data.shopId,
                shopsItemId: data.shopsItemId
            },
            headers: {
                'Accept-Language': data.acceptLanguage
            },
            query: {
                currency: data.currency,
                history: data.history
            },
            errors: {
                400: 'Bad request - invalid parameters',
                404: 'Item not found',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * Search items
     * Search for items using a text query with various filtering and sorting options.
     * Returns a paginated collection of items matching the search criteria.
     *
     * @param data The data for the request.
     * @param data.q Text search query (minimum 3 characters)
     * @param data.language Language for search and localized content
     * @param data.currency Currency for price display
     * @param data.sort Field to sort results by
     * @param data.order Sort order (only valid when sort is specified)
     * @param data.from Pagination offset (number of items to skip)
     * @param data.size Number of items to return per page
     * @returns CollectionData Search results returned successfully
     * @throws ApiError
     */
    public static getApiV1Items(data: GetApiV1ItemsData): CancelablePromise<GetApiV1ItemsResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/items',
            query: {
                q: data.q,
                language: data.language,
                currency: data.currency,
                sort: data.sort,
                order: data.order,
                from: data.from,
                size: data.size
            },
            errors: {
                400: 'Bad request - invalid parameters',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * Complex item search
     * Performs an advanced search for items using a comprehensive search filter.
     * This endpoint accepts a SearchFilterData object in the request body,
     * allowing for complex filtering by multiple criteria simultaneously.
     * Returns a paginated collection of items matching the search criteria.
     *
     * @param data The data for the request.
     * @param data.requestBody Search filter configuration with all filtering criteria.
     * Unlike the simple text search, this allows filtering by multiple fields,
     * price ranges, item states, and date ranges.
     *
     * @param data.sort Field to sort results by
     * @param data.order Sort order (only valid when sort is specified)
     * @param data.from Pagination offset (number of items to skip)
     * @param data.size Number of items to return per page
     * @returns CollectionData Complex search results returned successfully
     * @throws ApiError
     */
    public static postApiV1ItemsSearch(data: PostApiV1ItemsSearchData): CancelablePromise<PostApiV1ItemsSearchResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/items/search',
            query: {
                sort: data.sort,
                order: data.order,
                from: data.from,
                size: data.size
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad request - invalid parameters or body',
                500: 'Internal server error'
            }
        });
    }
    
}

export class SearchFiltersService {
    /**
     * List user search filters
     * Retrieves all search filters for the authenticated user.
     * Results can be optionally sorted by creation date.
     * Requires valid Cognito JWT authentication.
     *
     * @param data The data for the request.
     * @param data.authorization Cognito JWT token for user authentication
     * @param data.sort Field to sort results by
     * @param data.order Sort order (only valid when sort is specified)
     * @returns CollectionDataUserSearchFilter Search filters retrieved successfully
     * @throws ApiError
     */
    public static getApiV1SearchFilters(data: GetApiV1SearchFiltersData): CancelablePromise<GetApiV1SearchFiltersResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/search-filters',
            headers: {
                Authorization: data.authorization
            },
            query: {
                sort: data.sort,
                order: data.order
            },
            errors: {
                400: 'Bad request - invalid parameters',
                401: 'Unauthorized - invalid or missing JWT token',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * Create a new search filter
     * Creates a new search filter for the authenticated user.
     * The search filter configuration is provided in the request body.
     * Returns the created search filter with generated ID and metadata.
     * Requires valid Cognito JWT authentication.
     *
     * @param data The data for the request.
     * @param data.authorization Cognito JWT token for user authentication
     * @param data.requestBody Search filter configuration
     * @returns UserSearchFilterData Search filter created successfully
     * @throws ApiError
     */
    public static postApiV1SearchFilters(data: PostApiV1SearchFiltersData): CancelablePromise<PostApiV1SearchFiltersResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/api/v1/search-filters',
            headers: {
                Authorization: data.authorization
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad request - invalid request body',
                401: 'Unauthorized - invalid or missing JWT token',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * Get a specific search filter
     * Retrieves a specific search filter by its ID for the authenticated user.
     * Returns the complete search filter configuration and metadata.
     * Requires valid Cognito JWT authentication.
     *
     * @param data The data for the request.
     * @param data.searchFilterId Unique identifier of the search filter
     * @param data.authorization Cognito JWT token for user authentication
     * @returns UserSearchFilterData Search filter found and returned successfully
     * @throws ApiError
     */
    public static getApiV1SearchFiltersBySearchFilterId(data: GetApiV1SearchFiltersBySearchFilterIdData): CancelablePromise<GetApiV1SearchFiltersBySearchFilterIdResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/api/v1/search-filters/{searchFilterId}',
            path: {
                searchFilterId: data.searchFilterId
            },
            headers: {
                Authorization: data.authorization
            },
            errors: {
                400: 'Bad request - invalid parameters',
                401: 'Unauthorized - invalid or missing JWT token',
                404: 'Search filter not found',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * Delete a search filter
     * Deletes a specific search filter by its ID for the authenticated user.
     * The search filter must exist and belong to the authenticated user.
     * Requires valid Cognito JWT authentication.
     *
     * @param data The data for the request.
     * @param data.searchFilterId Unique identifier of the search filter to delete
     * @param data.authorization Cognito JWT token for user authentication
     * @returns string Search filter deleted successfully
     * @throws ApiError
     */
    public static deleteApiV1SearchFiltersBySearchFilterId(data: DeleteApiV1SearchFiltersBySearchFilterIdData): CancelablePromise<DeleteApiV1SearchFiltersBySearchFilterIdResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/api/v1/search-filters/{searchFilterId}',
            path: {
                searchFilterId: data.searchFilterId
            },
            headers: {
                Authorization: data.authorization
            },
            responseHeader: 'Access-Control-Allow-Origin',
            errors: {
                400: 'Bad request - invalid parameters',
                401: 'Unauthorized - invalid or missing JWT token',
                404: 'Search filter not found',
                500: 'Internal server error'
            }
        });
    }
    
    /**
     * Update a search filter
     * Updates a specific search filter by its ID for the authenticated user.
     * Allows partial updates - only provided fields will be modified.
     * If no fields are provided in the request body, returns the existing search filter unchanged.
     * Requires valid Cognito JWT authentication.
     *
     * @param data The data for the request.
     * @param data.searchFilterId Unique identifier of the search filter to update
     * @param data.authorization Cognito JWT token for user authentication
     * @param data.requestBody Partial search filter update data.
     * Only provided fields will be updated. If body is empty, returns existing filter.
     *
     * @returns UserSearchFilterData Search filter updated successfully
     * @throws ApiError
     */
    public static patchApiV1SearchFiltersBySearchFilterId(data: PatchApiV1SearchFiltersBySearchFilterIdData): CancelablePromise<PatchApiV1SearchFiltersBySearchFilterIdResponse> {
        return __request(OpenAPI, {
            method: 'PATCH',
            url: '/api/v1/search-filters/{searchFilterId}',
            path: {
                searchFilterId: data.searchFilterId
            },
            headers: {
                Authorization: data.authorization
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad request - invalid parameters or body',
                401: 'Unauthorized - invalid or missing JWT token',
                404: 'Search filter not found',
                500: 'Internal server error'
            }
        });
    }
    
}